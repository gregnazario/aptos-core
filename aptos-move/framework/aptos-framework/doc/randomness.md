
<a id="0x1_randomness"></a>

# Module `0x1::randomness`

This module provides access to &#42;instant&#42; secure randomness generated by the Aptos validators, as documented in
[AIP&#45;41](https://github.com/aptos&#45;foundation/AIPs/blob/main/aips/aip&#45;41.md).

Secure randomness means (1) the randomness cannot be predicted ahead of time by validators, developers or users
and (2) the randomness cannot be biased in any way by validators, developers or users.

Security holds under the same proof&#45;of&#45;stake assumption that secures the Aptos network.


-  [Resource `PerBlockRandomness`](#0x1_randomness_PerBlockRandomness)
-  [Struct `RandomnessGeneratedEvent`](#0x1_randomness_RandomnessGeneratedEvent)
-  [Resource `Ghost$var`](#0x1_randomness_Ghost$var)
-  [Constants](#@Constants_0)
-  [Function `initialize`](#0x1_randomness_initialize)
-  [Function `on_new_block`](#0x1_randomness_on_new_block)
-  [Function `next_32_bytes`](#0x1_randomness_next_32_bytes)
-  [Function `bytes`](#0x1_randomness_bytes)
-  [Function `u8_integer`](#0x1_randomness_u8_integer)
-  [Function `u16_integer`](#0x1_randomness_u16_integer)
-  [Function `u32_integer`](#0x1_randomness_u32_integer)
-  [Function `u64_integer`](#0x1_randomness_u64_integer)
-  [Function `u128_integer`](#0x1_randomness_u128_integer)
-  [Function `u256_integer`](#0x1_randomness_u256_integer)
-  [Function `u256_integer_internal`](#0x1_randomness_u256_integer_internal)
-  [Function `u8_range`](#0x1_randomness_u8_range)
-  [Function `u16_range`](#0x1_randomness_u16_range)
-  [Function `u32_range`](#0x1_randomness_u32_range)
-  [Function `u64_range`](#0x1_randomness_u64_range)
-  [Function `u64_range_internal`](#0x1_randomness_u64_range_internal)
-  [Function `u128_range`](#0x1_randomness_u128_range)
-  [Function `u256_range`](#0x1_randomness_u256_range)
-  [Function `permutation`](#0x1_randomness_permutation)
-  [Function `safe_add_mod`](#0x1_randomness_safe_add_mod)
-  [Function `safe_add_mod_for_verification`](#0x1_randomness_safe_add_mod_for_verification)
-  [Function `fetch_and_increment_txn_counter`](#0x1_randomness_fetch_and_increment_txn_counter)
-  [Function `is_unbiasable`](#0x1_randomness_is_unbiasable)
-  [Specification](#@Specification_1)
    -  [Function `initialize`](#@Specification_1_initialize)
    -  [Function `on_new_block`](#@Specification_1_on_new_block)
    -  [Function `next_32_bytes`](#@Specification_1_next_32_bytes)
    -  [Function `u8_integer`](#@Specification_1_u8_integer)
    -  [Function `u16_integer`](#@Specification_1_u16_integer)
    -  [Function `u32_integer`](#@Specification_1_u32_integer)
    -  [Function `u64_integer`](#@Specification_1_u64_integer)
    -  [Function `u128_integer`](#@Specification_1_u128_integer)
    -  [Function `u256_integer`](#@Specification_1_u256_integer)
    -  [Function `u256_integer_internal`](#@Specification_1_u256_integer_internal)
    -  [Function `u8_range`](#@Specification_1_u8_range)
    -  [Function `u64_range`](#@Specification_1_u64_range)
    -  [Function `u256_range`](#@Specification_1_u256_range)
    -  [Function `permutation`](#@Specification_1_permutation)
    -  [Function `safe_add_mod_for_verification`](#@Specification_1_safe_add_mod_for_verification)
    -  [Function `fetch_and_increment_txn_counter`](#@Specification_1_fetch_and_increment_txn_counter)
    -  [Function `is_unbiasable`](#@Specification_1_is_unbiasable)


```move
module 0x1::randomness {
    use 0x1::event;
    use 0x1::hash;
    use 0x1::option;
    use 0x1::system_addresses;
    use 0x1::transaction_context;
    use 0x1::vector;
}
```


<a id="0x1_randomness_PerBlockRandomness"></a>

## Resource `PerBlockRandomness`

32&#45;byte randomness seed unique to every block.
This resource is updated in every block prologue.


```move
module 0x1::randomness {
    struct PerBlockRandomness has drop, key
}
```


##### Fields


<dl>
<dt>
`epoch: u64`
</dt>
<dd>

</dd>
<dt>
`round: u64`
</dt>
<dd>

</dd>
<dt>
`seed: option::Option<vector<u8>>`
</dt>
<dd>

</dd>
</dl>


<a id="0x1_randomness_RandomnessGeneratedEvent"></a>

## Struct `RandomnessGeneratedEvent`

Event emitted every time a public randomness API in this module is called.


```move
module 0x1::randomness {
    #[event]
    struct RandomnessGeneratedEvent has drop, store
}
```


##### Fields


<dl>
<dt>
`dummy_field: bool`
</dt>
<dd>

</dd>
</dl>


<a id="0x1_randomness_Ghost$var"></a>

## Resource `Ghost$var`



```move
module 0x1::randomness {
    struct Ghost$var has copy, drop, store, key
}
```


##### Fields


<dl>
<dt>
`v: vector<u8>`
</dt>
<dd>

</dd>
</dl>


<a id="@Constants_0"></a>

## Constants


<a id="0x1_randomness_MAX_U256"></a>



```move
module 0x1::randomness {
    const MAX_U256: u256 = 115792089237316195423570985008687907853269984665640564039457584007913129639935;
}
```


<a id="0x1_randomness_DST"></a>



```move
module 0x1::randomness {
    const DST: vector<u8> = [65, 80, 84, 79, 83, 95, 82, 65, 78, 68, 79, 77, 78, 69, 83, 83];
}
```


<a id="0x1_randomness_E_API_USE_IS_BIASIBLE"></a>

Randomness APIs calls must originate from a private entry function with
`#[randomness]` annotation. Otherwise, malicious users can bias randomness result.


```move
module 0x1::randomness {
    const E_API_USE_IS_BIASIBLE: u64 = 1;
}
```


<a id="0x1_randomness_initialize"></a>

## Function `initialize`

Called in genesis.move.
Must be called in tests to initialize the `PerBlockRandomness` resource.


```move
module 0x1::randomness {
    public fun initialize(framework: &signer)
}
```


##### Implementation


```move
module 0x1::randomness {
    public fun initialize(framework: &signer) {
        system_addresses::assert_aptos_framework(framework);
        if (!exists<PerBlockRandomness>(@aptos_framework)) {
            move_to(framework, PerBlockRandomness {
                epoch: 0,
                round: 0,
                seed: option::none(),
            });
        }
    }
}
```


<a id="0x1_randomness_on_new_block"></a>

## Function `on_new_block`

Invoked in block prologues to update the block&#45;level randomness seed.


```move
module 0x1::randomness {
    public(friend) fun on_new_block(vm: &signer, epoch: u64, round: u64, seed_for_new_block: option::Option<vector<u8>>)
}
```


##### Implementation


```move
module 0x1::randomness {
    public(friend) fun on_new_block(vm: &signer, epoch: u64, round: u64, seed_for_new_block: Option<vector<u8>>) acquires PerBlockRandomness {
        system_addresses::assert_vm(vm);
        if (exists<PerBlockRandomness>(@aptos_framework)) {
            let randomness = borrow_global_mut<PerBlockRandomness>(@aptos_framework);
            randomness.epoch = epoch;
            randomness.round = round;
            randomness.seed = seed_for_new_block;
        }
    }
}
```


<a id="0x1_randomness_next_32_bytes"></a>

## Function `next_32_bytes`

Generate the next 32 random bytes. Repeated calls will yield different results (assuming the collision&#45;resistance
of the hash function).


```move
module 0x1::randomness {
    fun next_32_bytes(): vector<u8>
}
```


##### Implementation


```move
module 0x1::randomness {
    fun next_32_bytes(): vector<u8> acquires PerBlockRandomness {
        assert!(is_unbiasable(), E_API_USE_IS_BIASIBLE);

        let input = DST;
        let randomness = borrow_global<PerBlockRandomness>(@aptos_framework);
        let seed = *option::borrow(&randomness.seed);

        vector::append(&mut input, seed);
        vector::append(&mut input, transaction_context::get_transaction_hash());
        vector::append(&mut input, fetch_and_increment_txn_counter());
        hash::sha3_256(input)
    }
}
```


<a id="0x1_randomness_bytes"></a>

## Function `bytes`

Generates a sequence of bytes uniformly at random


```move
module 0x1::randomness {
    public fun bytes(n: u64): vector<u8>
}
```


##### Implementation


```move
module 0x1::randomness {
    public fun bytes(n: u64): vector<u8> acquires PerBlockRandomness {
        let v = vector[];
        let c = 0;
        while (c < n) {
            let blob = next_32_bytes();
            vector::append(&mut v, blob);

            c = c + 32;
        };

        if (c > n) {
            vector::trim(&mut v, n);
        };

        event::emit(RandomnessGeneratedEvent {});

        v
    }
}
```


<a id="0x1_randomness_u8_integer"></a>

## Function `u8_integer`

Generates an u8 uniformly at random.


```move
module 0x1::randomness {
    public fun u8_integer(): u8
}
```


##### Implementation


```move
module 0x1::randomness {
    public fun u8_integer(): u8 acquires PerBlockRandomness {
        let raw = next_32_bytes();
        let ret: u8 = vector::pop_back(&mut raw);

        event::emit(RandomnessGeneratedEvent {});

        ret
    }
}
```


<a id="0x1_randomness_u16_integer"></a>

## Function `u16_integer`

Generates an u16 uniformly at random.


```move
module 0x1::randomness {
    public fun u16_integer(): u16
}
```


##### Implementation


```move
module 0x1::randomness {
    public fun u16_integer(): u16 acquires PerBlockRandomness {
        let raw = next_32_bytes();
        let i = 0;
        let ret: u16 = 0;
        while (i < 2) {
            ret = ret * 256 + (vector::pop_back(&mut raw) as u16);
            i = i + 1;
        };

        event::emit(RandomnessGeneratedEvent {});

        ret
    }
}
```


<a id="0x1_randomness_u32_integer"></a>

## Function `u32_integer`

Generates an u32 uniformly at random.


```move
module 0x1::randomness {
    public fun u32_integer(): u32
}
```


##### Implementation


```move
module 0x1::randomness {
    public fun u32_integer(): u32 acquires PerBlockRandomness {
        let raw = next_32_bytes();
        let i = 0;
        let ret: u32 = 0;
        while (i < 4) {
            ret = ret * 256 + (vector::pop_back(&mut raw) as u32);
            i = i + 1;
        };

        event::emit(RandomnessGeneratedEvent {});

        ret
    }
}
```


<a id="0x1_randomness_u64_integer"></a>

## Function `u64_integer`

Generates an u64 uniformly at random.


```move
module 0x1::randomness {
    public fun u64_integer(): u64
}
```


##### Implementation


```move
module 0x1::randomness {
    public fun u64_integer(): u64 acquires PerBlockRandomness {
        let raw = next_32_bytes();
        let i = 0;
        let ret: u64 = 0;
        while (i < 8) {
            ret = ret * 256 + (vector::pop_back(&mut raw) as u64);
            i = i + 1;
        };

        event::emit(RandomnessGeneratedEvent {});

        ret
    }
}
```


<a id="0x1_randomness_u128_integer"></a>

## Function `u128_integer`

Generates an u128 uniformly at random.


```move
module 0x1::randomness {
    public fun u128_integer(): u128
}
```


##### Implementation


```move
module 0x1::randomness {
    public fun u128_integer(): u128 acquires PerBlockRandomness {
        let raw = next_32_bytes();
        let i = 0;
        let ret: u128 = 0;
        while (i < 16) {
            ret = ret * 256 + (vector::pop_back(&mut raw) as u128);
            i = i + 1;
        };

        event::emit(RandomnessGeneratedEvent {});

        ret
    }
}
```


<a id="0x1_randomness_u256_integer"></a>

## Function `u256_integer`

Generates a u256 uniformly at random.


```move
module 0x1::randomness {
    public fun u256_integer(): u256
}
```


##### Implementation


```move
module 0x1::randomness {
    public fun u256_integer(): u256 acquires PerBlockRandomness {
        event::emit(RandomnessGeneratedEvent {});
        u256_integer_internal()
    }
}
```


<a id="0x1_randomness_u256_integer_internal"></a>

## Function `u256_integer_internal`

Generates a u256 uniformly at random.


```move
module 0x1::randomness {
    fun u256_integer_internal(): u256
}
```


##### Implementation


```move
module 0x1::randomness {
    fun u256_integer_internal(): u256 acquires PerBlockRandomness {
        let raw = next_32_bytes();
        let i = 0;
        let ret: u256 = 0;
        while (i < 32) {
            ret = ret * 256 + (vector::pop_back(&mut raw) as u256);
            i = i + 1;
        };
        ret
    }
}
```


<a id="0x1_randomness_u8_range"></a>

## Function `u8_range`

Generates a number $n \in [min_incl, max_excl)$ uniformly at random.

NOTE: The uniformity is not perfect, but it can be proved that the bias is negligible.
If you need perfect uniformity, consider implement your own via rejection sampling.


```move
module 0x1::randomness {
    public fun u8_range(min_incl: u8, max_excl: u8): u8
}
```


##### Implementation


```move
module 0x1::randomness {
    public fun u8_range(min_incl: u8, max_excl: u8): u8 acquires PerBlockRandomness {
        let range = ((max_excl - min_incl) as u256);
        let sample = ((u256_integer_internal() % range) as u8);

        event::emit(RandomnessGeneratedEvent {});

        min_incl + sample
    }
}
```


<a id="0x1_randomness_u16_range"></a>

## Function `u16_range`

Generates a number $n \in [min_incl, max_excl)$ uniformly at random.

NOTE: The uniformity is not perfect, but it can be proved that the bias is negligible.
If you need perfect uniformity, consider implement your own via rejection sampling.


```move
module 0x1::randomness {
    public fun u16_range(min_incl: u16, max_excl: u16): u16
}
```


##### Implementation


```move
module 0x1::randomness {
    public fun u16_range(min_incl: u16, max_excl: u16): u16 acquires PerBlockRandomness {
        let range = ((max_excl - min_incl) as u256);
        let sample = ((u256_integer_internal() % range) as u16);

        event::emit(RandomnessGeneratedEvent {});

        min_incl + sample
    }
}
```


<a id="0x1_randomness_u32_range"></a>

## Function `u32_range`

Generates a number $n \in [min_incl, max_excl)$ uniformly at random.

NOTE: The uniformity is not perfect, but it can be proved that the bias is negligible.
If you need perfect uniformity, consider implement your own via rejection sampling.


```move
module 0x1::randomness {
    public fun u32_range(min_incl: u32, max_excl: u32): u32
}
```


##### Implementation


```move
module 0x1::randomness {
    public fun u32_range(min_incl: u32, max_excl: u32): u32 acquires PerBlockRandomness {
        let range = ((max_excl - min_incl) as u256);
        let sample = ((u256_integer_internal() % range) as u32);

        event::emit(RandomnessGeneratedEvent {});

        min_incl + sample
    }
}
```


<a id="0x1_randomness_u64_range"></a>

## Function `u64_range`

Generates a number $n \in [min_incl, max_excl)$ uniformly at random.

NOTE: The uniformity is not perfect, but it can be proved that the bias is negligible.
If you need perfect uniformity, consider implement your own via rejection sampling.


```move
module 0x1::randomness {
    public fun u64_range(min_incl: u64, max_excl: u64): u64
}
```


##### Implementation


```move
module 0x1::randomness {
    public fun u64_range(min_incl: u64, max_excl: u64): u64 acquires PerBlockRandomness {
        event::emit(RandomnessGeneratedEvent {});

        u64_range_internal(min_incl, max_excl)
    }
}
```


<a id="0x1_randomness_u64_range_internal"></a>

## Function `u64_range_internal`



```move
module 0x1::randomness {
    public fun u64_range_internal(min_incl: u64, max_excl: u64): u64
}
```


##### Implementation


```move
module 0x1::randomness {
    public fun u64_range_internal(min_incl: u64, max_excl: u64): u64 acquires PerBlockRandomness {
        let range = ((max_excl - min_incl) as u256);
        let sample = ((u256_integer_internal() % range) as u64);

        min_incl + sample
    }
}
```


<a id="0x1_randomness_u128_range"></a>

## Function `u128_range`

Generates a number $n \in [min_incl, max_excl)$ uniformly at random.

NOTE: The uniformity is not perfect, but it can be proved that the bias is negligible.
If you need perfect uniformity, consider implement your own via rejection sampling.


```move
module 0x1::randomness {
    public fun u128_range(min_incl: u128, max_excl: u128): u128
}
```


##### Implementation


```move
module 0x1::randomness {
    public fun u128_range(min_incl: u128, max_excl: u128): u128 acquires PerBlockRandomness {
        let range = ((max_excl - min_incl) as u256);
        let sample = ((u256_integer_internal() % range) as u128);

        event::emit(RandomnessGeneratedEvent {});

        min_incl + sample
    }
}
```


<a id="0x1_randomness_u256_range"></a>

## Function `u256_range`

Generates a number $n \in [min_incl, max_excl)$ uniformly at random.

NOTE: The uniformity is not perfect, but it can be proved that the bias is negligible.
If you need perfect uniformity, consider implement your own with `u256_integer()` &#43; rejection sampling.


```move
module 0x1::randomness {
    public fun u256_range(min_incl: u256, max_excl: u256): u256
}
```


##### Implementation


```move
module 0x1::randomness {
    public fun u256_range(min_incl: u256, max_excl: u256): u256 acquires PerBlockRandomness {
        let range = max_excl - min_incl;
        let r0 = u256_integer_internal();
        let r1 = u256_integer_internal();

        // Will compute sample := (r0 + r1*2^256) % range.

        let sample = r1 % range;
        let i = 0;
        while ({
            spec {
                invariant sample >= 0 && sample < max_excl - min_incl;
            };
            i < 256
        }) {
            sample = safe_add_mod(sample, sample, range);
            i = i + 1;
        };

        let sample = safe_add_mod(sample, r0 % range, range);
        spec {
            assert sample >= 0 && sample < max_excl - min_incl;
        };

        event::emit(RandomnessGeneratedEvent {});

        min_incl + sample
    }
}
```


<a id="0x1_randomness_permutation"></a>

## Function `permutation`

Generate a permutation of `[0, 1, ..., n-1]` uniformly at random.
If n is 0, returns the empty vector.


```move
module 0x1::randomness {
    public fun permutation(n: u64): vector<u64>
}
```


##### Implementation


```move
module 0x1::randomness {
    public fun permutation(n: u64): vector<u64> acquires PerBlockRandomness {
        let values = vector[];

        if(n == 0) {
            return vector[]
        };

        // Initialize into [0, 1, ..., n-1].
        let i = 0;
        while ({
            spec {
                invariant i <= n;
                invariant len(values) == i;
            };
            i < n
        }) {
            std::vector::push_back(&mut values, i);
            i = i + 1;
        };
        spec {
            assert len(values) == n;
        };

        // Shuffle.
        let tail = n - 1;
        while ({
            spec {
                invariant tail >= 0 && tail < len(values);
            };
            tail > 0
        }) {
            let pop_position = u64_range_internal(0, tail + 1);
            spec {
                assert pop_position < len(values);
            };
            std::vector::swap(&mut values, pop_position, tail);
            tail = tail - 1;
        };

        event::emit(RandomnessGeneratedEvent {});

        values
    }
}
```


<a id="0x1_randomness_safe_add_mod"></a>

## Function `safe_add_mod`

Compute `(a + b) % m`, assuming `m >= 1, 0 <= a < m, 0<= b < m`.


```move
module 0x1::randomness {
    fun safe_add_mod(a: u256, b: u256, m: u256): u256
}
```


##### Implementation


```move
module 0x1::randomness {
    inline fun safe_add_mod(a: u256, b: u256, m: u256): u256 {
        let neg_b = m - b;
        if (a < neg_b) {
            a + b
        } else {
            a - neg_b
        }
    }
}
```


<a id="0x1_randomness_safe_add_mod_for_verification"></a>

## Function `safe_add_mod_for_verification`



```move
module 0x1::randomness {
    #[verify_only]
    fun safe_add_mod_for_verification(a: u256, b: u256, m: u256): u256
}
```


##### Implementation


```move
module 0x1::randomness {
    fun safe_add_mod_for_verification(a: u256, b: u256, m: u256): u256 {
        let neg_b = m - b;
        if (a < neg_b) {
            a + b
        } else {
            a - neg_b
        }
    }
}
```


<a id="0x1_randomness_fetch_and_increment_txn_counter"></a>

## Function `fetch_and_increment_txn_counter`

Fetches and increments a transaction&#45;specific 32&#45;byte randomness&#45;related counter.
Aborts with `E_API_USE_SUSCEPTIBLE_TO_TEST_AND_ABORT` if randomness is not unbiasable.


```move
module 0x1::randomness {
    fun fetch_and_increment_txn_counter(): vector<u8>
}
```


##### Implementation


```move
module 0x1::randomness {
    native fun fetch_and_increment_txn_counter(): vector<u8>;
}
```


<a id="0x1_randomness_is_unbiasable"></a>

## Function `is_unbiasable`

Called in each randomness generation function to ensure certain safety invariants, namely:
1. The transaction that led to the call of this function had a private (or friend) entry
function as its payload.
2. The entry function had `#[randomness]` annotation.


```move
module 0x1::randomness {
    fun is_unbiasable(): bool
}
```


##### Implementation


```move
module 0x1::randomness {
    native fun is_unbiasable(): bool;
}
```


<a id="@Specification_1"></a>

## Specification



```move
module 0x1::randomness {
    pragma verify = true;
    invariant [suspendable] chain_status::is_operating() ==> exists<PerBlockRandomness>(@aptos_framework);
<a id="0x1_randomness_var"></a>
    global var: vector<u8>;
}
```


<a id="@Specification_1_initialize"></a>

### Function `initialize`


```move
module 0x1::randomness {
    public fun initialize(framework: &signer)
}
```



```move
module 0x1::randomness {
    let framework_addr = signer::address_of(framework);
    aborts_if framework_addr != @aptos_framework;
}
```


<a id="@Specification_1_on_new_block"></a>

### Function `on_new_block`


```move
module 0x1::randomness {
    public(friend) fun on_new_block(vm: &signer, epoch: u64, round: u64, seed_for_new_block: option::Option<vector<u8>>)
}
```



```move
module 0x1::randomness {
    aborts_if signer::address_of(vm) != @vm;
    ensures exists<PerBlockRandomness>(@aptos_framework) ==> global<PerBlockRandomness>(@aptos_framework).seed == seed_for_new_block;
    ensures exists<PerBlockRandomness>(@aptos_framework) ==> global<PerBlockRandomness>(@aptos_framework).epoch == epoch;
    ensures exists<PerBlockRandomness>(@aptos_framework) ==> global<PerBlockRandomness>(@aptos_framework).round == round;
}
```


<a id="@Specification_1_next_32_bytes"></a>

### Function `next_32_bytes`


```move
module 0x1::randomness {
    fun next_32_bytes(): vector<u8>
}
```



```move
module 0x1::randomness {
    include NextBlobAbortsIf;
    let input = b"APTOS_RANDOMNESS";
    let randomness = global<PerBlockRandomness>(@aptos_framework);
    let seed = option::spec_borrow(randomness.seed);
    let txn_hash = transaction_context::spec_get_txn_hash();
    let txn_counter = spec_fetch_and_increment_txn_counter();
    ensures len(result) == 32;
    ensures result == hash::sha3_256(concat(concat(concat(input, seed), txn_hash), txn_counter));
}
```



<a id="0x1_randomness_NextBlobAbortsIf"></a>


```move
module 0x1::randomness {
    schema NextBlobAbortsIf {
        let randomness = global<PerBlockRandomness>(@aptos_framework);
        aborts_if option::spec_is_none(randomness.seed);
        aborts_if !spec_is_unbiasable();
        aborts_if !exists<PerBlockRandomness>(@aptos_framework);
    }
}
```


<a id="@Specification_1_u8_integer"></a>

### Function `u8_integer`


```move
module 0x1::randomness {
    public fun u8_integer(): u8
}
```



```move
module 0x1::randomness {
    include NextBlobAbortsIf;
}
```


<a id="@Specification_1_u16_integer"></a>

### Function `u16_integer`


```move
module 0x1::randomness {
    public fun u16_integer(): u16
}
```



```move
module 0x1::randomness {
    pragma unroll = 2;
    include NextBlobAbortsIf;
}
```


<a id="@Specification_1_u32_integer"></a>

### Function `u32_integer`


```move
module 0x1::randomness {
    public fun u32_integer(): u32
}
```



```move
module 0x1::randomness {
    pragma unroll = 4;
    include NextBlobAbortsIf;
}
```


<a id="@Specification_1_u64_integer"></a>

### Function `u64_integer`


```move
module 0x1::randomness {
    public fun u64_integer(): u64
}
```



```move
module 0x1::randomness {
    pragma unroll = 8;
    include NextBlobAbortsIf;
}
```


<a id="@Specification_1_u128_integer"></a>

### Function `u128_integer`


```move
module 0x1::randomness {
    public fun u128_integer(): u128
}
```



```move
module 0x1::randomness {
    pragma unroll = 16;
    include NextBlobAbortsIf;
}
```


<a id="@Specification_1_u256_integer"></a>

### Function `u256_integer`


```move
module 0x1::randomness {
    public fun u256_integer(): u256
}
```



```move
module 0x1::randomness {
    pragma verify_duration_estimate = 300;
    pragma unroll = 32;
    include NextBlobAbortsIf;
    ensures [abstract] result == spec_u256_integer();
}
```


<a id="@Specification_1_u256_integer_internal"></a>

### Function `u256_integer_internal`


```move
module 0x1::randomness {
    fun u256_integer_internal(): u256
}
```



```move
module 0x1::randomness {
    pragma verify_duration_estimate = 300;
    pragma unroll = 32;
    include NextBlobAbortsIf;
}
```



<a id="0x1_randomness_spec_u256_integer"></a>


```move
module 0x1::randomness {
    fun spec_u256_integer(): u256;
}
```


<a id="@Specification_1_u8_range"></a>

### Function `u8_range`


```move
module 0x1::randomness {
    public fun u8_range(min_incl: u8, max_excl: u8): u8
}
```



```move
module 0x1::randomness {
    pragma verify_duration_estimate = 120;
    pragma opaque;
    include NextBlobAbortsIf;
    aborts_if min_incl >= max_excl;
    ensures result >= min_incl && result < max_excl;
}
```


<a id="@Specification_1_u64_range"></a>

### Function `u64_range`


```move
module 0x1::randomness {
    public fun u64_range(min_incl: u64, max_excl: u64): u64
}
```



```move
module 0x1::randomness {
    pragma verify_duration_estimate = 120;
    include NextBlobAbortsIf;
    aborts_if min_incl >= max_excl;
    ensures result >= min_incl && result < max_excl;
}
```


<a id="@Specification_1_u256_range"></a>

### Function `u256_range`


```move
module 0x1::randomness {
    public fun u256_range(min_incl: u256, max_excl: u256): u256
}
```



```move
module 0x1::randomness {
    pragma verify_duration_estimate = 120;
    include NextBlobAbortsIf;
    aborts_if min_incl >= max_excl;
    ensures result >= min_incl && result < max_excl;
}
```


<a id="@Specification_1_permutation"></a>

### Function `permutation`


```move
module 0x1::randomness {
    public fun permutation(n: u64): vector<u64>
}
```



```move
module 0x1::randomness {
    pragma aborts_if_is_partial;
}
```


<a id="@Specification_1_safe_add_mod_for_verification"></a>

### Function `safe_add_mod_for_verification`


```move
module 0x1::randomness {
    #[verify_only]
    fun safe_add_mod_for_verification(a: u256, b: u256, m: u256): u256
}
```



```move
module 0x1::randomness {
    aborts_if m < b;
    aborts_if a < m - b && a + b > MAX_U256;
    ensures result == spec_safe_add_mod(a, b, m);
}
```



<a id="0x1_randomness_spec_safe_add_mod"></a>


```move
module 0x1::randomness {
    fun spec_safe_add_mod(a: u256, b: u256, m: u256): u256 {
       if (a < m - b) {
           a + b
       } else {
           a - (m - b)
       }
    }
}
```


<a id="@Specification_1_fetch_and_increment_txn_counter"></a>

### Function `fetch_and_increment_txn_counter`


```move
module 0x1::randomness {
    fun fetch_and_increment_txn_counter(): vector<u8>
}
```



```move
module 0x1::randomness {
    pragma opaque;
    aborts_if [abstract] false;
    ensures [abstract] result == spec_fetch_and_increment_txn_counter();
}
```



<a id="0x1_randomness_spec_fetch_and_increment_txn_counter"></a>


```move
module 0x1::randomness {
    fun spec_fetch_and_increment_txn_counter(): vector<u8>;
}
```


<a id="@Specification_1_is_unbiasable"></a>

### Function `is_unbiasable`


```move
module 0x1::randomness {
    fun is_unbiasable(): bool
}
```



```move
module 0x1::randomness {
    pragma opaque;
    aborts_if [abstract] false;
    ensures [abstract] result == spec_is_unbiasable();
}
```



<a id="0x1_randomness_spec_is_unbiasable"></a>


```move
module 0x1::randomness {
    fun spec_is_unbiasable(): bool;
}
```
