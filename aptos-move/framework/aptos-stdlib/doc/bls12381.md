
<a id="0x1_bls12381"></a>

# Module `0x1::bls12381`

Contains functions for:

The minimum&#45;pubkey&#45;size variant of [Boneh&#45;Lynn&#45;Shacham (BLS) signatures](https://en.wikipedia.org/wiki/BLS_digital_signature),
where public keys are BLS12&#45;381 elliptic&#45;curve points in $\mathbb&#123;G&#125;_1$ and signatures are in $\mathbb&#123;G&#125;_2$,
as per the [IETF BLS draft standard](https://datatracker.ietf.org/doc/html/draft&#45;irtf&#45;cfrg&#45;bls&#45;signature#section&#45;2.1).


-  [Struct `PublicKey`](#0x1_bls12381_PublicKey)
-  [Struct `ProofOfPossession`](#0x1_bls12381_ProofOfPossession)
-  [Struct `PublicKeyWithPoP`](#0x1_bls12381_PublicKeyWithPoP)
-  [Struct `AggrPublicKeysWithPoP`](#0x1_bls12381_AggrPublicKeysWithPoP)
-  [Struct `Signature`](#0x1_bls12381_Signature)
-  [Struct `AggrOrMultiSignature`](#0x1_bls12381_AggrOrMultiSignature)
-  [Constants](#@Constants_0)
-  [Function `public_key_from_bytes`](#0x1_bls12381_public_key_from_bytes)
-  [Function `public_key_to_bytes`](#0x1_bls12381_public_key_to_bytes)
-  [Function `proof_of_possession_from_bytes`](#0x1_bls12381_proof_of_possession_from_bytes)
-  [Function `proof_of_possession_to_bytes`](#0x1_bls12381_proof_of_possession_to_bytes)
-  [Function `public_key_from_bytes_with_pop`](#0x1_bls12381_public_key_from_bytes_with_pop)
-  [Function `public_key_with_pop_to_normal`](#0x1_bls12381_public_key_with_pop_to_normal)
-  [Function `public_key_with_pop_to_bytes`](#0x1_bls12381_public_key_with_pop_to_bytes)
-  [Function `signature_from_bytes`](#0x1_bls12381_signature_from_bytes)
-  [Function `signature_to_bytes`](#0x1_bls12381_signature_to_bytes)
-  [Function `signature_subgroup_check`](#0x1_bls12381_signature_subgroup_check)
-  [Function `aggregate_pubkeys`](#0x1_bls12381_aggregate_pubkeys)
-  [Function `aggregate_pubkey_to_bytes`](#0x1_bls12381_aggregate_pubkey_to_bytes)
-  [Function `aggregate_signatures`](#0x1_bls12381_aggregate_signatures)
-  [Function `aggr_or_multi_signature_to_bytes`](#0x1_bls12381_aggr_or_multi_signature_to_bytes)
-  [Function `aggr_or_multi_signature_from_bytes`](#0x1_bls12381_aggr_or_multi_signature_from_bytes)
-  [Function `aggr_or_multi_signature_subgroup_check`](#0x1_bls12381_aggr_or_multi_signature_subgroup_check)
-  [Function `verify_aggregate_signature`](#0x1_bls12381_verify_aggregate_signature)
-  [Function `verify_multisignature`](#0x1_bls12381_verify_multisignature)
-  [Function `verify_normal_signature`](#0x1_bls12381_verify_normal_signature)
-  [Function `verify_signature_share`](#0x1_bls12381_verify_signature_share)
-  [Function `aggregate_pubkeys_internal`](#0x1_bls12381_aggregate_pubkeys_internal)
-  [Function `aggregate_signatures_internal`](#0x1_bls12381_aggregate_signatures_internal)
-  [Function `validate_pubkey_internal`](#0x1_bls12381_validate_pubkey_internal)
-  [Function `signature_subgroup_check_internal`](#0x1_bls12381_signature_subgroup_check_internal)
-  [Function `verify_aggregate_signature_internal`](#0x1_bls12381_verify_aggregate_signature_internal)
-  [Function `verify_multisignature_internal`](#0x1_bls12381_verify_multisignature_internal)
-  [Function `verify_normal_signature_internal`](#0x1_bls12381_verify_normal_signature_internal)
-  [Function `verify_proof_of_possession_internal`](#0x1_bls12381_verify_proof_of_possession_internal)
-  [Function `verify_signature_share_internal`](#0x1_bls12381_verify_signature_share_internal)
-  [Specification](#@Specification_1)
    -  [Function `public_key_from_bytes`](#@Specification_1_public_key_from_bytes)
    -  [Function `public_key_from_bytes_with_pop`](#@Specification_1_public_key_from_bytes_with_pop)
    -  [Function `aggregate_pubkeys`](#@Specification_1_aggregate_pubkeys)
    -  [Function `aggregate_signatures`](#@Specification_1_aggregate_signatures)
    -  [Function `aggr_or_multi_signature_from_bytes`](#@Specification_1_aggr_or_multi_signature_from_bytes)
    -  [Function `aggr_or_multi_signature_subgroup_check`](#@Specification_1_aggr_or_multi_signature_subgroup_check)
    -  [Function `verify_aggregate_signature`](#@Specification_1_verify_aggregate_signature)
    -  [Function `verify_multisignature`](#@Specification_1_verify_multisignature)
    -  [Function `verify_normal_signature`](#@Specification_1_verify_normal_signature)
    -  [Function `verify_signature_share`](#@Specification_1_verify_signature_share)
    -  [Function `aggregate_pubkeys_internal`](#@Specification_1_aggregate_pubkeys_internal)
    -  [Function `aggregate_signatures_internal`](#@Specification_1_aggregate_signatures_internal)
    -  [Function `validate_pubkey_internal`](#@Specification_1_validate_pubkey_internal)
    -  [Function `signature_subgroup_check_internal`](#@Specification_1_signature_subgroup_check_internal)
    -  [Function `verify_aggregate_signature_internal`](#@Specification_1_verify_aggregate_signature_internal)
    -  [Function `verify_multisignature_internal`](#@Specification_1_verify_multisignature_internal)
    -  [Function `verify_normal_signature_internal`](#@Specification_1_verify_normal_signature_internal)
    -  [Function `verify_proof_of_possession_internal`](#@Specification_1_verify_proof_of_possession_internal)
    -  [Function `verify_signature_share_internal`](#@Specification_1_verify_signature_share_internal)
    -  [Helper functions](#@Helper_functions_2)


```move
module 0x1::bls12381 {
    use 0x1::error;
    use 0x1::option;
}
```


<a id="0x1_bls12381_PublicKey"></a>

## Struct `PublicKey`

A &#42;validated&#42; public key that:
(1) is a point in the prime&#45;order subgroup of the BLS12&#45;381 elliptic curve, and
(2) is not the identity point

This struct can be used to verify a normal (non&#45;aggregated) signature.

This struct can be combined with a ProofOfPossession struct in order to create a PublicKeyWithPop struct, which
can be used to verify a multisignature.


```move
module 0x1::bls12381 {
    struct PublicKey has copy, drop, store
}
```


##### Fields


<dl>
<dt>
`bytes: vector<u8>`
</dt>
<dd>

</dd>
</dl>


<a id="0x1_bls12381_ProofOfPossession"></a>

## Struct `ProofOfPossession`

A proof&#45;of&#45;possession (PoP).
Given such a struct and a PublicKey struct, one can construct a PublicKeyWithPoP (see below).


```move
module 0x1::bls12381 {
    struct ProofOfPossession has copy, drop, store
}
```


##### Fields


<dl>
<dt>
`bytes: vector<u8>`
</dt>
<dd>

</dd>
</dl>


<a id="0x1_bls12381_PublicKeyWithPoP"></a>

## Struct `PublicKeyWithPoP`

A &#42;validated&#42; public key that had a successfully&#45;verified proof&#45;of&#45;possession (PoP).

A vector of these structs can be either:
(1) used to verify an aggregate signature
(2) aggregated with other PublicKeyWithPoP structs into an AggrPublicKeysWithPoP, which in turn can be used
to verify a multisignature


```move
module 0x1::bls12381 {
    struct PublicKeyWithPoP has copy, drop, store
}
```


##### Fields


<dl>
<dt>
`bytes: vector<u8>`
</dt>
<dd>

</dd>
</dl>


<a id="0x1_bls12381_AggrPublicKeysWithPoP"></a>

## Struct `AggrPublicKeysWithPoP`

An aggregation of public keys with verified PoPs, which can be used to verify multisignatures.


```move
module 0x1::bls12381 {
    struct AggrPublicKeysWithPoP has copy, drop, store
}
```


##### Fields


<dl>
<dt>
`bytes: vector<u8>`
</dt>
<dd>

</dd>
</dl>


<a id="0x1_bls12381_Signature"></a>

## Struct `Signature`

A BLS signature. This can be either a:
(1) normal (non&#45;aggregated) signature
(2) signature share (for a multisignature or aggregate signature)


```move
module 0x1::bls12381 {
    struct Signature has copy, drop, store
}
```


##### Fields


<dl>
<dt>
`bytes: vector<u8>`
</dt>
<dd>

</dd>
</dl>


<a id="0x1_bls12381_AggrOrMultiSignature"></a>

## Struct `AggrOrMultiSignature`

An aggregation of BLS signatures. This can be either a:
(4) aggregated signature (i.e., an aggregation of signatures s_i, each on a message m_i)
(3) multisignature (i.e., an aggregation of signatures s_i, each on the same message m)

We distinguish between a Signature type and a AggrOrMultiSignature type to prevent developers from interchangeably
calling `verify_multisignature` and `verify_signature_share` to verify both multisignatures and signature shares,
which could create problems down the line.


```move
module 0x1::bls12381 {
    struct AggrOrMultiSignature has copy, drop, store
}
```


##### Fields


<dl>
<dt>
`bytes: vector<u8>`
</dt>
<dd>

</dd>
</dl>


<a id="@Constants_0"></a>

## Constants


<a id="0x1_bls12381_EWRONG_SIZE"></a>

One of the given inputs has the wrong size.s


```move
module 0x1::bls12381 {
    const EWRONG_SIZE: u64 = 2;
}
```


<a id="0x1_bls12381_EZERO_PUBKEYS"></a>

The caller was supposed to input one or more public keys.


```move
module 0x1::bls12381 {
    const EZERO_PUBKEYS: u64 = 1;
}
```


<a id="0x1_bls12381_E_NUM_SIGNERS_MUST_EQ_NUM_MESSAGES"></a>

The number of signers does not match the number of messages to be signed.


```move
module 0x1::bls12381 {
    const E_NUM_SIGNERS_MUST_EQ_NUM_MESSAGES: u64 = 3;
}
```


<a id="0x1_bls12381_PUBLIC_KEY_NUM_BYTES"></a>

The public key size, in bytes


```move
module 0x1::bls12381 {
    const PUBLIC_KEY_NUM_BYTES: u64 = 48;
}
```


<a id="0x1_bls12381_RANDOM_PK"></a>

Random signature generated by running `cargo test -- bls12381_sample_signature --nocapture --include-ignored` in `crates/aptos-crypto`.
The associated SK is 07416693b6b32c84abe45578728e2379f525729e5b94762435a31e65ecc728da.


```move
module 0x1::bls12381 {
    const RANDOM_PK: vector<u8> = [138, 83, 231, 174, 82, 112, 227, 231, 101, 205, 138, 64, 50, 194, 231, 124, 111, 126, 135, 164, 78, 187, 133, 191, 40, 164, 215, 134, 85, 101, 105, 143, 151, 83, 70, 113, 66, 98, 249, 228, 124, 111, 62, 13, 93, 149, 22, 96];
}
```


<a id="0x1_bls12381_RANDOM_SIGNATURE"></a>

Random signature generated by running `cargo test -- bls12381_sample_signature --nocapture --include-ignored` in `crates/aptos-crypto`.
The message signed is &quot;Hello Aptos!&quot; and the associated SK is 07416693b6b32c84abe45578728e2379f525729e5b94762435a31e65ecc728da.


```move
module 0x1::bls12381 {
    const RANDOM_SIGNATURE: vector<u8> = [160, 26, 101, 133, 79, 152, 125, 52, 52, 20, 155, 127, 8, 247, 7, 48, 227, 11, 36, 25, 132, 232, 113, 43, 194, 172, 168, 133, 214, 50, 170, 252, 237, 76, 63, 102, 18, 9, 222, 187, 107, 28, 134, 1, 50, 102, 35, 204, 22, 202, 47, 108, 158, 220, 83, 183, 184, 139, 116, 53, 251, 107, 5, 221, 236, 228, 24, 210, 195, 77, 198, 172, 162, 245, 161, 26, 121, 230, 119, 116, 88, 44, 20, 8, 74, 1, 220, 183, 130, 14, 76, 180, 186, 208, 234, 141];
}
```


<a id="0x1_bls12381_SIGNATURE_SIZE"></a>

The signature size, in bytes


```move
module 0x1::bls12381 {
    const SIGNATURE_SIZE: u64 = 96;
}
```


<a id="0x1_bls12381_public_key_from_bytes"></a>

## Function `public_key_from_bytes`

Creates a new public key from a sequence of bytes.


```move
module 0x1::bls12381 {
    public fun public_key_from_bytes(bytes: vector<u8>): option::Option<bls12381::PublicKey>
}
```


##### Implementation


```move
module 0x1::bls12381 {
    public fun public_key_from_bytes(bytes: vector<u8>): Option<PublicKey> {
        if (validate_pubkey_internal(bytes)) {
            option::some(PublicKey {
                bytes
            })
        } else {
            option::none<PublicKey>()
        }
    }
}
```


<a id="0x1_bls12381_public_key_to_bytes"></a>

## Function `public_key_to_bytes`

Serializes a public key into 48 bytes.


```move
module 0x1::bls12381 {
    public fun public_key_to_bytes(pk: &bls12381::PublicKey): vector<u8>
}
```


##### Implementation


```move
module 0x1::bls12381 {
    public fun public_key_to_bytes(pk: &PublicKey): vector<u8> {
        pk.bytes
    }
}
```


<a id="0x1_bls12381_proof_of_possession_from_bytes"></a>

## Function `proof_of_possession_from_bytes`

Creates a new proof&#45;of&#45;possession (PoP) which can be later used to create a PublicKeyWithPoP struct,


```move
module 0x1::bls12381 {
    public fun proof_of_possession_from_bytes(bytes: vector<u8>): bls12381::ProofOfPossession
}
```


##### Implementation


```move
module 0x1::bls12381 {
    public fun proof_of_possession_from_bytes(bytes: vector<u8>): ProofOfPossession {
        ProofOfPossession {
            bytes
        }
    }
}
```


<a id="0x1_bls12381_proof_of_possession_to_bytes"></a>

## Function `proof_of_possession_to_bytes`

Serializes the signature into 96 bytes.


```move
module 0x1::bls12381 {
    public fun proof_of_possession_to_bytes(pop: &bls12381::ProofOfPossession): vector<u8>
}
```


##### Implementation


```move
module 0x1::bls12381 {
    public fun proof_of_possession_to_bytes(pop: &ProofOfPossession): vector<u8> {
        pop.bytes
    }
}
```


<a id="0x1_bls12381_public_key_from_bytes_with_pop"></a>

## Function `public_key_from_bytes_with_pop`

Creates a PoP&apos;d public key from a normal public key and a corresponding proof&#45;of&#45;possession.


```move
module 0x1::bls12381 {
    public fun public_key_from_bytes_with_pop(pk_bytes: vector<u8>, pop: &bls12381::ProofOfPossession): option::Option<bls12381::PublicKeyWithPoP>
}
```


##### Implementation


```move
module 0x1::bls12381 {
    public fun public_key_from_bytes_with_pop(pk_bytes: vector<u8>, pop: &ProofOfPossession): Option<PublicKeyWithPoP> {
        if (verify_proof_of_possession_internal(pk_bytes, pop.bytes)) {
            option::some(PublicKeyWithPoP {
                bytes: pk_bytes
            })
        } else {
            option::none<PublicKeyWithPoP>()
        }
    }
}
```


<a id="0x1_bls12381_public_key_with_pop_to_normal"></a>

## Function `public_key_with_pop_to_normal`

Creates a normal public key from a PoP&apos;d public key.


```move
module 0x1::bls12381 {
    public fun public_key_with_pop_to_normal(pkpop: &bls12381::PublicKeyWithPoP): bls12381::PublicKey
}
```


##### Implementation


```move
module 0x1::bls12381 {
    public fun public_key_with_pop_to_normal(pkpop: &PublicKeyWithPoP): PublicKey {
        PublicKey {
            bytes: pkpop.bytes
        }
    }
}
```


<a id="0x1_bls12381_public_key_with_pop_to_bytes"></a>

## Function `public_key_with_pop_to_bytes`

Serializes a PoP&apos;d public key into 48 bytes.


```move
module 0x1::bls12381 {
    public fun public_key_with_pop_to_bytes(pk: &bls12381::PublicKeyWithPoP): vector<u8>
}
```


##### Implementation


```move
module 0x1::bls12381 {
    public fun public_key_with_pop_to_bytes(pk: &PublicKeyWithPoP): vector<u8> {
        pk.bytes
    }
}
```


<a id="0x1_bls12381_signature_from_bytes"></a>

## Function `signature_from_bytes`

Creates a new signature from a sequence of bytes. Does not check the signature for prime&#45;order subgroup
membership since that is done implicitly during verification.


```move
module 0x1::bls12381 {
    public fun signature_from_bytes(bytes: vector<u8>): bls12381::Signature
}
```


##### Implementation


```move
module 0x1::bls12381 {
    public fun signature_from_bytes(bytes: vector<u8>): Signature {
        Signature {
            bytes
        }
    }
}
```


<a id="0x1_bls12381_signature_to_bytes"></a>

## Function `signature_to_bytes`

Serializes the signature into 96 bytes.


```move
module 0x1::bls12381 {
    public fun signature_to_bytes(sig: &bls12381::Signature): vector<u8>
}
```


##### Implementation


```move
module 0x1::bls12381 {
    public fun signature_to_bytes(sig: &Signature): vector<u8> {
        sig.bytes
    }
}
```


<a id="0x1_bls12381_signature_subgroup_check"></a>

## Function `signature_subgroup_check`

Checks that the group element that defines a signature is in the prime&#45;order subgroup.
This check is implicitly performed when verifying any signature via this module, but we expose this functionality
in case it might be useful for applications to easily dismiss invalid signatures early on.


```move
module 0x1::bls12381 {
    public fun signature_subgroup_check(signature: &bls12381::Signature): bool
}
```


##### Implementation


```move
module 0x1::bls12381 {
    public fun signature_subgroup_check(signature: &Signature): bool {
        signature_subgroup_check_internal(signature.bytes)
    }
}
```


<a id="0x1_bls12381_aggregate_pubkeys"></a>

## Function `aggregate_pubkeys`

Given a vector of public keys with verified PoPs, combines them into an &#42;aggregated&#42; public key which can be used
to verify multisignatures using `verify_multisignature` and aggregate signatures using `verify_aggregate_signature`.
Aborts if no public keys are given as input.


```move
module 0x1::bls12381 {
    public fun aggregate_pubkeys(public_keys: vector<bls12381::PublicKeyWithPoP>): bls12381::AggrPublicKeysWithPoP
}
```


##### Implementation


```move
module 0x1::bls12381 {
    public fun aggregate_pubkeys(public_keys: vector<PublicKeyWithPoP>): AggrPublicKeysWithPoP {
        let (bytes, success) = aggregate_pubkeys_internal(public_keys);
        assert!(success, std::error::invalid_argument(EZERO_PUBKEYS));

        AggrPublicKeysWithPoP {
            bytes
        }
    }
}
```


<a id="0x1_bls12381_aggregate_pubkey_to_bytes"></a>

## Function `aggregate_pubkey_to_bytes`

Serializes an aggregate public key into 48 bytes.


```move
module 0x1::bls12381 {
    public fun aggregate_pubkey_to_bytes(apk: &bls12381::AggrPublicKeysWithPoP): vector<u8>
}
```


##### Implementation


```move
module 0x1::bls12381 {
    public fun aggregate_pubkey_to_bytes(apk: &AggrPublicKeysWithPoP): vector<u8> {
        apk.bytes
    }
}
```


<a id="0x1_bls12381_aggregate_signatures"></a>

## Function `aggregate_signatures`

Aggregates the input signatures into an aggregate&#45;or&#45;multi&#45;signature structure, which can be later verified via
`verify_aggregate_signature` or `verify_multisignature`. Returns `None` if zero signatures are given as input
or if some of the signatures are not valid group elements.


```move
module 0x1::bls12381 {
    public fun aggregate_signatures(signatures: vector<bls12381::Signature>): option::Option<bls12381::AggrOrMultiSignature>
}
```


##### Implementation


```move
module 0x1::bls12381 {
    public fun aggregate_signatures(signatures: vector<Signature>): Option<AggrOrMultiSignature> {
        let (bytes, success) = aggregate_signatures_internal(signatures);
        if (success) {
            option::some(
                AggrOrMultiSignature {
                    bytes
                }
            )
        } else {
            option::none<AggrOrMultiSignature>()
        }
    }
}
```


<a id="0x1_bls12381_aggr_or_multi_signature_to_bytes"></a>

## Function `aggr_or_multi_signature_to_bytes`

Serializes an aggregate&#45;or&#45;multi&#45;signature into 96 bytes.


```move
module 0x1::bls12381 {
    public fun aggr_or_multi_signature_to_bytes(sig: &bls12381::AggrOrMultiSignature): vector<u8>
}
```


##### Implementation


```move
module 0x1::bls12381 {
    public fun aggr_or_multi_signature_to_bytes(sig: &AggrOrMultiSignature): vector<u8> {
        sig.bytes
    }
}
```


<a id="0x1_bls12381_aggr_or_multi_signature_from_bytes"></a>

## Function `aggr_or_multi_signature_from_bytes`

Deserializes an aggregate&#45;or&#45;multi&#45;signature from 96 bytes.


```move
module 0x1::bls12381 {
    public fun aggr_or_multi_signature_from_bytes(bytes: vector<u8>): bls12381::AggrOrMultiSignature
}
```


##### Implementation


```move
module 0x1::bls12381 {
    public fun aggr_or_multi_signature_from_bytes(bytes: vector<u8>): AggrOrMultiSignature {
        assert!(std::vector::length(&bytes) == SIGNATURE_SIZE, std::error::invalid_argument(EWRONG_SIZE));

        AggrOrMultiSignature {
            bytes
        }
    }
}
```


<a id="0x1_bls12381_aggr_or_multi_signature_subgroup_check"></a>

## Function `aggr_or_multi_signature_subgroup_check`

Checks that the group element that defines an aggregate&#45;or&#45;multi&#45;signature is in the prime&#45;order subgroup.


```move
module 0x1::bls12381 {
    public fun aggr_or_multi_signature_subgroup_check(signature: &bls12381::AggrOrMultiSignature): bool
}
```


##### Implementation


```move
module 0x1::bls12381 {
    public fun aggr_or_multi_signature_subgroup_check(signature: &AggrOrMultiSignature): bool {
        signature_subgroup_check_internal(signature.bytes)
    }
}
```


<a id="0x1_bls12381_verify_aggregate_signature"></a>

## Function `verify_aggregate_signature`

Verifies an aggregate signature, an aggregation of many signatures `s_i`, each on a different message `m_i`.


```move
module 0x1::bls12381 {
    public fun verify_aggregate_signature(aggr_sig: &bls12381::AggrOrMultiSignature, public_keys: vector<bls12381::PublicKeyWithPoP>, messages: vector<vector<u8>>): bool
}
```


##### Implementation


```move
module 0x1::bls12381 {
    public fun verify_aggregate_signature(
        aggr_sig: &AggrOrMultiSignature,
        public_keys: vector<PublicKeyWithPoP>,
        messages: vector<vector<u8>>,
    ): bool {
        verify_aggregate_signature_internal(aggr_sig.bytes, public_keys, messages)
    }
}
```


<a id="0x1_bls12381_verify_multisignature"></a>

## Function `verify_multisignature`

Verifies a multisignature: an aggregation of many signatures, each on the same message `m`.


```move
module 0x1::bls12381 {
    public fun verify_multisignature(multisig: &bls12381::AggrOrMultiSignature, aggr_public_key: &bls12381::AggrPublicKeysWithPoP, message: vector<u8>): bool
}
```


##### Implementation


```move
module 0x1::bls12381 {
    public fun verify_multisignature(
        multisig: &AggrOrMultiSignature,
        aggr_public_key: &AggrPublicKeysWithPoP,
        message: vector<u8>
    ): bool {
        verify_multisignature_internal(multisig.bytes, aggr_public_key.bytes, message)
    }
}
```


<a id="0x1_bls12381_verify_normal_signature"></a>

## Function `verify_normal_signature`

Verifies a normal, non&#45;aggregated signature.


```move
module 0x1::bls12381 {
    public fun verify_normal_signature(signature: &bls12381::Signature, public_key: &bls12381::PublicKey, message: vector<u8>): bool
}
```


##### Implementation


```move
module 0x1::bls12381 {
    public fun verify_normal_signature(
        signature: &Signature,
        public_key: &PublicKey,
        message: vector<u8>
    ): bool {
        verify_normal_signature_internal(signature.bytes, public_key.bytes, message)
    }
}
```


<a id="0x1_bls12381_verify_signature_share"></a>

## Function `verify_signature_share`

Verifies a signature share in the multisignature share or an aggregate signature share.


```move
module 0x1::bls12381 {
    public fun verify_signature_share(signature_share: &bls12381::Signature, public_key: &bls12381::PublicKeyWithPoP, message: vector<u8>): bool
}
```


##### Implementation


```move
module 0x1::bls12381 {
    public fun verify_signature_share(
        signature_share: &Signature,
        public_key: &PublicKeyWithPoP,
        message: vector<u8>
    ): bool {
        verify_signature_share_internal(signature_share.bytes, public_key.bytes, message)
    }
}
```


<a id="0x1_bls12381_aggregate_pubkeys_internal"></a>

## Function `aggregate_pubkeys_internal`

CRYPTOGRAPHY WARNING: This function assumes that the caller verified all public keys have a valid
proof&#45;of&#45;possesion (PoP) using `verify_proof_of_possession`.

Given a vector of serialized public keys, combines them into an aggregated public key, returning `(bytes, true)`,
where `bytes` store the serialized public key.
Aborts if no public keys are given as input.


```move
module 0x1::bls12381 {
    fun aggregate_pubkeys_internal(public_keys: vector<bls12381::PublicKeyWithPoP>): (vector<u8>, bool)
}
```


##### Implementation


```move
module 0x1::bls12381 {
    native fun aggregate_pubkeys_internal(public_keys: vector<PublicKeyWithPoP>): (vector<u8>, bool);
}
```


<a id="0x1_bls12381_aggregate_signatures_internal"></a>

## Function `aggregate_signatures_internal`

CRYPTOGRAPHY WARNING: This function can be safely called without verifying that the input signatures are elements
of the prime&#45;order subgroup of the BLS12&#45;381 curve.

Given a vector of serialized signatures, combines them into an aggregate signature, returning `(bytes, true)`,
where `bytes` store the serialized signature.
Does not check the input signatures nor the final aggregated signatures for prime&#45;order subgroup membership.
Returns `(_, false)` if no signatures are given as input.
Does not abort.


```move
module 0x1::bls12381 {
    fun aggregate_signatures_internal(signatures: vector<bls12381::Signature>): (vector<u8>, bool)
}
```


##### Implementation


```move
module 0x1::bls12381 {
    native fun aggregate_signatures_internal(signatures: vector<Signature>): (vector<u8>, bool);
}
```


<a id="0x1_bls12381_validate_pubkey_internal"></a>

## Function `validate_pubkey_internal`

Return `true` if the bytes in `public_key` are a valid BLS12&#45;381 public key:
(1) it is NOT the identity point, and
(2) it is a BLS12&#45;381 elliptic curve point, and
(3) it is a prime&#45;order point
Return `false` otherwise.
Does not abort.


```move
module 0x1::bls12381 {
    fun validate_pubkey_internal(public_key: vector<u8>): bool
}
```


##### Implementation


```move
module 0x1::bls12381 {
    native fun validate_pubkey_internal(public_key: vector<u8>): bool;
}
```


<a id="0x1_bls12381_signature_subgroup_check_internal"></a>

## Function `signature_subgroup_check_internal`

Return `true` if the elliptic curve point serialized in `signature`:
(1) is NOT the identity point, and
(2) is a BLS12&#45;381 elliptic curve point, and
(3) is a prime&#45;order point
Return `false` otherwise.
Does not abort.


```move
module 0x1::bls12381 {
    fun signature_subgroup_check_internal(signature: vector<u8>): bool
}
```


##### Implementation


```move
module 0x1::bls12381 {
    native fun signature_subgroup_check_internal(signature: vector<u8>): bool;
}
```


<a id="0x1_bls12381_verify_aggregate_signature_internal"></a>

## Function `verify_aggregate_signature_internal`

CRYPTOGRAPHY WARNING: First, this function assumes all public keys have a valid proof&#45;of&#45;possesion (PoP).
This prevents both small&#45;subgroup attacks and rogue&#45;key attacks. Second, this function can be safely called
without verifying that the aggregate signature is in the prime&#45;order subgroup of the BLS12&#45;381 curve.

Returns `true` if the aggregate signature `aggsig` on `messages` under `public_keys` verifies (where `messages[i]`
should be signed by `public_keys[i]`).

Returns `false` if either:
&#45; no public keys or messages are given as input,
&#45; number of messages does not equal number of public keys
&#45; `aggsig` (1) is the identity point, or (2) is NOT a BLS12&#45;381 elliptic curve point, or (3) is NOT a
prime&#45;order point
Does not abort.


```move
module 0x1::bls12381 {
    fun verify_aggregate_signature_internal(aggsig: vector<u8>, public_keys: vector<bls12381::PublicKeyWithPoP>, messages: vector<vector<u8>>): bool
}
```


##### Implementation


```move
module 0x1::bls12381 {
    native fun verify_aggregate_signature_internal(
        aggsig: vector<u8>,
        public_keys: vector<PublicKeyWithPoP>,
        messages: vector<vector<u8>>,
    ): bool;
}
```


<a id="0x1_bls12381_verify_multisignature_internal"></a>

## Function `verify_multisignature_internal`

CRYPTOGRAPHY WARNING: This function assumes verified proofs&#45;of&#45;possesion (PoP) for the public keys used in
computing the aggregate public key. This prevents small&#45;subgroup attacks and rogue&#45;key attacks.

Return `true` if the BLS `multisignature` on `message` verifies against the BLS aggregate public key `agg_public_key`.
Returns `false` otherwise.
Does not abort.


```move
module 0x1::bls12381 {
    fun verify_multisignature_internal(multisignature: vector<u8>, agg_public_key: vector<u8>, message: vector<u8>): bool
}
```


##### Implementation


```move
module 0x1::bls12381 {
    native fun verify_multisignature_internal(
        multisignature: vector<u8>,
        agg_public_key: vector<u8>,
        message: vector<u8>
    ): bool;
}
```


<a id="0x1_bls12381_verify_normal_signature_internal"></a>

## Function `verify_normal_signature_internal`

CRYPTOGRAPHY WARNING: This function WILL check that the public key is a prime&#45;order point, in order to prevent
library users from misusing the library by forgetting to validate public keys before giving them as arguments to
this function.

Returns `true` if the `signature` on `message` verifies under `public key`.
Returns `false` otherwise.
Does not abort.


```move
module 0x1::bls12381 {
    fun verify_normal_signature_internal(signature: vector<u8>, public_key: vector<u8>, message: vector<u8>): bool
}
```


##### Implementation


```move
module 0x1::bls12381 {
    native fun verify_normal_signature_internal(
        signature: vector<u8>,
        public_key: vector<u8>,
        message: vector<u8>
    ): bool;
}
```


<a id="0x1_bls12381_verify_proof_of_possession_internal"></a>

## Function `verify_proof_of_possession_internal`

Return `true` if the bytes in `public_key` are a valid bls12381 public key (as per `validate_pubkey`)
&#42;and&#42; this public key has a valid proof&#45;of&#45;possesion (PoP).
Return `false` otherwise.
Does not abort.


```move
module 0x1::bls12381 {
    fun verify_proof_of_possession_internal(public_key: vector<u8>, proof_of_possesion: vector<u8>): bool
}
```


##### Implementation


```move
module 0x1::bls12381 {
    native fun verify_proof_of_possession_internal(
        public_key: vector<u8>,
        proof_of_possesion: vector<u8>
    ): bool;
}
```


<a id="0x1_bls12381_verify_signature_share_internal"></a>

## Function `verify_signature_share_internal`

CRYPTOGRAPHY WARNING: Assumes the public key has a valid proof&#45;of&#45;possesion (PoP). This prevents rogue&#45;key
attacks later on during signature aggregation.

Returns `true` if the `signature_share` on `message` verifies under `public key`.
Returns `false` otherwise, similar to `verify_multisignature`.
Does not abort.


```move
module 0x1::bls12381 {
    fun verify_signature_share_internal(signature_share: vector<u8>, public_key: vector<u8>, message: vector<u8>): bool
}
```


##### Implementation


```move
module 0x1::bls12381 {
    native fun verify_signature_share_internal(
        signature_share: vector<u8>,
        public_key: vector<u8>,
        message: vector<u8>
    ): bool;
}
```


<a id="@Specification_1"></a>

## Specification


<a id="@Specification_1_public_key_from_bytes"></a>

### Function `public_key_from_bytes`


```move
module 0x1::bls12381 {
    public fun public_key_from_bytes(bytes: vector<u8>): option::Option<bls12381::PublicKey>
}
```



```move
module 0x1::bls12381 {
    aborts_if false;
    ensures spec_validate_pubkey_internal(bytes) ==> (std::option::spec_is_some(result) && std::option::spec_borrow(result).bytes == bytes);
    ensures !spec_validate_pubkey_internal(bytes) ==> std::option::spec_is_none(result);
}
```


<a id="@Specification_1_public_key_from_bytes_with_pop"></a>

### Function `public_key_from_bytes_with_pop`


```move
module 0x1::bls12381 {
    public fun public_key_from_bytes_with_pop(pk_bytes: vector<u8>, pop: &bls12381::ProofOfPossession): option::Option<bls12381::PublicKeyWithPoP>
}
```



```move
module 0x1::bls12381 {
    pragma opaque;
    aborts_if false;
    ensures spec_verify_proof_of_possession_internal(pk_bytes, pop.bytes) ==> (std::option::spec_is_some(result) && std::option::spec_borrow(result).bytes == pk_bytes);
    ensures !spec_verify_proof_of_possession_internal(pk_bytes, pop.bytes) ==> std::option::spec_is_none(result);
    ensures [abstract] result == spec_public_key_from_bytes_with_pop(pk_bytes, pop);
}
```


<a id="@Specification_1_aggregate_pubkeys"></a>

### Function `aggregate_pubkeys`


```move
module 0x1::bls12381 {
    public fun aggregate_pubkeys(public_keys: vector<bls12381::PublicKeyWithPoP>): bls12381::AggrPublicKeysWithPoP
}
```



```move
module 0x1::bls12381 {
    let bytes = spec_aggregate_pubkeys_internal_1(public_keys);
    let success = spec_aggregate_pubkeys_internal_2(public_keys);
    aborts_if !success;
    ensures result.bytes == bytes;
}
```


<a id="@Specification_1_aggregate_signatures"></a>

### Function `aggregate_signatures`


```move
module 0x1::bls12381 {
    public fun aggregate_signatures(signatures: vector<bls12381::Signature>): option::Option<bls12381::AggrOrMultiSignature>
}
```



```move
module 0x1::bls12381 {
    aborts_if false;
    let bytes = spec_aggregate_signatures_internal_1(signatures);
    let success = spec_aggregate_signatures_internal_2(signatures);
    ensures success ==> (std::option::spec_is_some(result) && std::option::spec_borrow(result).bytes == bytes);
    ensures !success ==> std::option::spec_is_none(result);
}
```


<a id="@Specification_1_aggr_or_multi_signature_from_bytes"></a>

### Function `aggr_or_multi_signature_from_bytes`


```move
module 0x1::bls12381 {
    public fun aggr_or_multi_signature_from_bytes(bytes: vector<u8>): bls12381::AggrOrMultiSignature
}
```



```move
module 0x1::bls12381 {
    aborts_if len(bytes) != SIGNATURE_SIZE;
    ensures result.bytes == bytes;
}
```


<a id="@Specification_1_aggr_or_multi_signature_subgroup_check"></a>

### Function `aggr_or_multi_signature_subgroup_check`


```move
module 0x1::bls12381 {
    public fun aggr_or_multi_signature_subgroup_check(signature: &bls12381::AggrOrMultiSignature): bool
}
```



```move
module 0x1::bls12381 {
    aborts_if false;
    ensures result == spec_signature_subgroup_check_internal(signature.bytes);
}
```


<a id="@Specification_1_verify_aggregate_signature"></a>

### Function `verify_aggregate_signature`


```move
module 0x1::bls12381 {
    public fun verify_aggregate_signature(aggr_sig: &bls12381::AggrOrMultiSignature, public_keys: vector<bls12381::PublicKeyWithPoP>, messages: vector<vector<u8>>): bool
}
```



```move
module 0x1::bls12381 {
    aborts_if false;
    ensures result == spec_verify_aggregate_signature_internal(aggr_sig.bytes, public_keys, messages);
}
```


<a id="@Specification_1_verify_multisignature"></a>

### Function `verify_multisignature`


```move
module 0x1::bls12381 {
    public fun verify_multisignature(multisig: &bls12381::AggrOrMultiSignature, aggr_public_key: &bls12381::AggrPublicKeysWithPoP, message: vector<u8>): bool
}
```



```move
module 0x1::bls12381 {
    aborts_if false;
    ensures result == spec_verify_multisignature_internal(multisig.bytes, aggr_public_key.bytes, message);
}
```


<a id="@Specification_1_verify_normal_signature"></a>

### Function `verify_normal_signature`


```move
module 0x1::bls12381 {
    public fun verify_normal_signature(signature: &bls12381::Signature, public_key: &bls12381::PublicKey, message: vector<u8>): bool
}
```



```move
module 0x1::bls12381 {
    aborts_if false;
    ensures result == spec_verify_normal_signature_internal(signature.bytes, public_key.bytes, message);
}
```


<a id="@Specification_1_verify_signature_share"></a>

### Function `verify_signature_share`


```move
module 0x1::bls12381 {
    public fun verify_signature_share(signature_share: &bls12381::Signature, public_key: &bls12381::PublicKeyWithPoP, message: vector<u8>): bool
}
```



```move
module 0x1::bls12381 {
    aborts_if false;
    ensures result == spec_verify_signature_share_internal(signature_share.bytes, public_key.bytes, message);
}
```


<a id="@Specification_1_aggregate_pubkeys_internal"></a>

### Function `aggregate_pubkeys_internal`


```move
module 0x1::bls12381 {
    fun aggregate_pubkeys_internal(public_keys: vector<bls12381::PublicKeyWithPoP>): (vector<u8>, bool)
}
```



```move
module 0x1::bls12381 {
    pragma opaque;
    aborts_if [abstract] false;
    ensures result_1 == spec_aggregate_pubkeys_internal_1(public_keys);
    ensures result_2 == spec_aggregate_pubkeys_internal_2(public_keys);
}
```


<a id="@Specification_1_aggregate_signatures_internal"></a>

### Function `aggregate_signatures_internal`


```move
module 0x1::bls12381 {
    fun aggregate_signatures_internal(signatures: vector<bls12381::Signature>): (vector<u8>, bool)
}
```



```move
module 0x1::bls12381 {
    pragma opaque;
    aborts_if [abstract] false;
    ensures result_1 == spec_aggregate_signatures_internal_1(signatures);
    ensures result_2 == spec_aggregate_signatures_internal_2(signatures);
}
```


<a id="@Specification_1_validate_pubkey_internal"></a>

### Function `validate_pubkey_internal`


```move
module 0x1::bls12381 {
    fun validate_pubkey_internal(public_key: vector<u8>): bool
}
```



```move
module 0x1::bls12381 {
    pragma opaque;
    aborts_if [abstract] false;
    ensures result == spec_validate_pubkey_internal(public_key);
}
```


<a id="@Specification_1_signature_subgroup_check_internal"></a>

### Function `signature_subgroup_check_internal`


```move
module 0x1::bls12381 {
    fun signature_subgroup_check_internal(signature: vector<u8>): bool
}
```



```move
module 0x1::bls12381 {
    pragma opaque;
    aborts_if [abstract] false;
    ensures result == spec_signature_subgroup_check_internal(signature);
}
```


<a id="@Specification_1_verify_aggregate_signature_internal"></a>

### Function `verify_aggregate_signature_internal`


```move
module 0x1::bls12381 {
    fun verify_aggregate_signature_internal(aggsig: vector<u8>, public_keys: vector<bls12381::PublicKeyWithPoP>, messages: vector<vector<u8>>): bool
}
```



```move
module 0x1::bls12381 {
    pragma opaque;
    aborts_if [abstract] false;
    ensures result == spec_verify_aggregate_signature_internal(aggsig, public_keys, messages);
}
```


<a id="@Specification_1_verify_multisignature_internal"></a>

### Function `verify_multisignature_internal`


```move
module 0x1::bls12381 {
    fun verify_multisignature_internal(multisignature: vector<u8>, agg_public_key: vector<u8>, message: vector<u8>): bool
}
```



```move
module 0x1::bls12381 {
    pragma opaque;
    aborts_if [abstract] false;
    ensures result == spec_verify_multisignature_internal(multisignature, agg_public_key, message);
}
```


<a id="@Specification_1_verify_normal_signature_internal"></a>

### Function `verify_normal_signature_internal`


```move
module 0x1::bls12381 {
    fun verify_normal_signature_internal(signature: vector<u8>, public_key: vector<u8>, message: vector<u8>): bool
}
```



```move
module 0x1::bls12381 {
    pragma opaque;
    aborts_if [abstract] false;
    ensures result == spec_verify_normal_signature_internal(signature, public_key, message);
}
```


<a id="@Specification_1_verify_proof_of_possession_internal"></a>

### Function `verify_proof_of_possession_internal`


```move
module 0x1::bls12381 {
    fun verify_proof_of_possession_internal(public_key: vector<u8>, proof_of_possesion: vector<u8>): bool
}
```



```move
module 0x1::bls12381 {
    pragma opaque;
    aborts_if [abstract] false;
    ensures result == spec_verify_proof_of_possession_internal(public_key, proof_of_possesion);
}
```


<a id="@Specification_1_verify_signature_share_internal"></a>

### Function `verify_signature_share_internal`


```move
module 0x1::bls12381 {
    fun verify_signature_share_internal(signature_share: vector<u8>, public_key: vector<u8>, message: vector<u8>): bool
}
```



```move
module 0x1::bls12381 {
    pragma opaque;
    aborts_if [abstract] false;
    ensures result == spec_verify_signature_share_internal(signature_share, public_key, message);
}
```


<a id="@Helper_functions_2"></a>

### Helper functions



<a id="0x1_bls12381_spec_aggregate_pubkeys_internal_1"></a>


```move
module 0x1::bls12381 {
    fun spec_aggregate_pubkeys_internal_1(public_keys: vector<PublicKeyWithPoP>): vector<u8>;
}
```



<a id="0x1_bls12381_spec_public_key_from_bytes_with_pop"></a>


```move
module 0x1::bls12381 {
    fun spec_public_key_from_bytes_with_pop(pk_bytes: vector<u8>, pop: ProofOfPossession): Option<PublicKeyWithPoP>;
}
```



<a id="0x1_bls12381_spec_aggregate_pubkeys_internal_2"></a>


```move
module 0x1::bls12381 {
    fun spec_aggregate_pubkeys_internal_2(public_keys: vector<PublicKeyWithPoP>): bool;
}
```



<a id="0x1_bls12381_spec_aggregate_signatures_internal_1"></a>


```move
module 0x1::bls12381 {
    fun spec_aggregate_signatures_internal_1(signatures: vector<Signature>): vector<u8>;
}
```



<a id="0x1_bls12381_spec_aggregate_signatures_internal_2"></a>


```move
module 0x1::bls12381 {
    fun spec_aggregate_signatures_internal_2(signatures: vector<Signature>): bool;
}
```



<a id="0x1_bls12381_spec_validate_pubkey_internal"></a>


```move
module 0x1::bls12381 {
    fun spec_validate_pubkey_internal(public_key: vector<u8>): bool;
}
```



<a id="0x1_bls12381_spec_signature_subgroup_check_internal"></a>


```move
module 0x1::bls12381 {
    fun spec_signature_subgroup_check_internal(signature: vector<u8>): bool;
}
```



<a id="0x1_bls12381_spec_verify_aggregate_signature_internal"></a>


```move
module 0x1::bls12381 {
    fun spec_verify_aggregate_signature_internal(
       aggsig: vector<u8>,
       public_keys: vector<PublicKeyWithPoP>,
       messages: vector<vector<u8>>,
    ): bool;
}
```



<a id="0x1_bls12381_spec_verify_multisignature_internal"></a>


```move
module 0x1::bls12381 {
    fun spec_verify_multisignature_internal(
       multisignature: vector<u8>,
       agg_public_key: vector<u8>,
       message: vector<u8>
    ): bool;
}
```



<a id="0x1_bls12381_spec_verify_normal_signature_internal"></a>


```move
module 0x1::bls12381 {
    fun spec_verify_normal_signature_internal(
       signature: vector<u8>,
       public_key: vector<u8>,
       message: vector<u8>
    ): bool;
}
```



<a id="0x1_bls12381_spec_verify_proof_of_possession_internal"></a>


```move
module 0x1::bls12381 {
    fun spec_verify_proof_of_possession_internal(
       public_key: vector<u8>,
       proof_of_possesion: vector<u8>
    ): bool;
}
```



<a id="0x1_bls12381_spec_verify_signature_share_internal"></a>


```move
module 0x1::bls12381 {
    fun spec_verify_signature_share_internal(
       signature_share: vector<u8>,
       public_key: vector<u8>,
       message: vector<u8>
    ): bool;
}
```
