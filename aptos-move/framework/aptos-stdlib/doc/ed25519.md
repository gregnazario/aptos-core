
<a id="0x1_ed25519"></a>

# Module `0x1::ed25519`

Contains functions for:

1. [Ed25519](https://en.wikipedia.org/wiki/EdDSA#Ed25519) digital signatures: i.e., EdDSA signatures over Edwards25519 curves with co-factor 8


-  [Struct `SignedMessage`](#0x1_ed25519_SignedMessage)
-  [Struct `UnvalidatedPublicKey`](#0x1_ed25519_UnvalidatedPublicKey)
-  [Struct `ValidatedPublicKey`](#0x1_ed25519_ValidatedPublicKey)
-  [Struct `Signature`](#0x1_ed25519_Signature)
-  [Constants](#@Constants_0)
-  [Function `new_unvalidated_public_key_from_bytes`](#0x1_ed25519_new_unvalidated_public_key_from_bytes)
-  [Function `new_validated_public_key_from_bytes`](#0x1_ed25519_new_validated_public_key_from_bytes)
-  [Function `new_signature_from_bytes`](#0x1_ed25519_new_signature_from_bytes)
-  [Function `public_key_to_unvalidated`](#0x1_ed25519_public_key_to_unvalidated)
-  [Function `public_key_into_unvalidated`](#0x1_ed25519_public_key_into_unvalidated)
-  [Function `unvalidated_public_key_to_bytes`](#0x1_ed25519_unvalidated_public_key_to_bytes)
-  [Function `validated_public_key_to_bytes`](#0x1_ed25519_validated_public_key_to_bytes)
-  [Function `signature_to_bytes`](#0x1_ed25519_signature_to_bytes)
-  [Function `public_key_validate`](#0x1_ed25519_public_key_validate)
-  [Function `signature_verify_strict`](#0x1_ed25519_signature_verify_strict)
-  [Function `signature_verify_strict_t`](#0x1_ed25519_signature_verify_strict_t)
-  [Function `new_signed_message`](#0x1_ed25519_new_signed_message)
-  [Function `unvalidated_public_key_to_authentication_key`](#0x1_ed25519_unvalidated_public_key_to_authentication_key)
-  [Function `validated_public_key_to_authentication_key`](#0x1_ed25519_validated_public_key_to_authentication_key)
-  [Function `public_key_bytes_to_authentication_key`](#0x1_ed25519_public_key_bytes_to_authentication_key)
-  [Function `public_key_validate_internal`](#0x1_ed25519_public_key_validate_internal)
-  [Function `signature_verify_strict_internal`](#0x1_ed25519_signature_verify_strict_internal)
-  [Specification](#@Specification_1)
    -  [Function `new_unvalidated_public_key_from_bytes`](#@Specification_1_new_unvalidated_public_key_from_bytes)
    -  [Function `new_validated_public_key_from_bytes`](#@Specification_1_new_validated_public_key_from_bytes)
    -  [Function `new_signature_from_bytes`](#@Specification_1_new_signature_from_bytes)
    -  [Function `public_key_bytes_to_authentication_key`](#@Specification_1_public_key_bytes_to_authentication_key)
    -  [Function `public_key_validate_internal`](#@Specification_1_public_key_validate_internal)
    -  [Function `signature_verify_strict_internal`](#@Specification_1_signature_verify_strict_internal)
    -  [Helper functions](#@Helper_functions_2)


<pre><code><b>use</b> [../../move-stdlib/doc/bcs.md#0x1_bcs](0x1::bcs);
<b>use</b> [../../move-stdlib/doc/error.md#0x1_error](0x1::error);
<b>use</b> [../../move-stdlib/doc/hash.md#0x1_hash](0x1::hash);
<b>use</b> [../../move-stdlib/doc/option.md#0x1_option](0x1::option);
<b>use</b> [type_info.md#0x1_type_info](0x1::type_info);
</code></pre>



<a id="0x1_ed25519_SignedMessage"></a>

## Struct `SignedMessage`

A BCS-serializable message, which one can verify signatures on via <code>signature_verify_strict_t</code>


<pre><code><b>struct</b> [ed25519.md#0x1_ed25519_SignedMessage](SignedMessage)&lt;MessageType&gt; <b>has</b> drop
</code></pre>



<details>
<summary>Fields</summary>


<dl>
<dt>
<code>[type_info.md#0x1_type_info](type_info): [type_info.md#0x1_type_info_TypeInfo](type_info::TypeInfo)</code>
</dt>
<dd>

</dd>
<dt>
<code>inner: MessageType</code>
</dt>
<dd>

</dd>
</dl>


</details>

<a id="0x1_ed25519_UnvalidatedPublicKey"></a>

## Struct `UnvalidatedPublicKey`

An *unvalidated* Ed25519 public key: not necessarily an elliptic curve point, just a sequence of 32 bytes


<pre><code><b>struct</b> [ed25519.md#0x1_ed25519_UnvalidatedPublicKey](UnvalidatedPublicKey) <b>has</b> <b>copy</b>, drop, store
</code></pre>



<details>
<summary>Fields</summary>


<dl>
<dt>
<code>bytes: [../../move-stdlib/doc/vector.md#0x1_vector](vector)&lt;u8&gt;</code>
</dt>
<dd>

</dd>
</dl>


</details>

<a id="0x1_ed25519_ValidatedPublicKey"></a>

## Struct `ValidatedPublicKey`

A *validated* Ed25519 public key: not necessarily a prime-order point, could be mixed-order, but will never be
a small-order point.

For now, this struct is not used in any verification functions, but it might be in the future.


<pre><code><b>struct</b> [ed25519.md#0x1_ed25519_ValidatedPublicKey](ValidatedPublicKey) <b>has</b> <b>copy</b>, drop, store
</code></pre>



<details>
<summary>Fields</summary>


<dl>
<dt>
<code>bytes: [../../move-stdlib/doc/vector.md#0x1_vector](vector)&lt;u8&gt;</code>
</dt>
<dd>

</dd>
</dl>


</details>

<a id="0x1_ed25519_Signature"></a>

## Struct `Signature`

A purported Ed25519 signature that can be verified via <code>signature_verify_strict</code> or <code>signature_verify_strict_t</code>.


<pre><code><b>struct</b> [ed25519.md#0x1_ed25519_Signature](Signature) <b>has</b> <b>copy</b>, drop, store
</code></pre>



<details>
<summary>Fields</summary>


<dl>
<dt>
<code>bytes: [../../move-stdlib/doc/vector.md#0x1_vector](vector)&lt;u8&gt;</code>
</dt>
<dd>

</dd>
</dl>


</details>

<a id="@Constants_0"></a>

## Constants


<a id="0x1_ed25519_PUBLIC_KEY_NUM_BYTES"></a>

The size of a serialized public key, in bytes.


<pre><code><b>const</b> [ed25519.md#0x1_ed25519_PUBLIC_KEY_NUM_BYTES](PUBLIC_KEY_NUM_BYTES): u64 = 32;
</code></pre>



<a id="0x1_ed25519_E_WRONG_PUBKEY_SIZE"></a>

Wrong number of bytes were given as input when deserializing an Ed25519 public key.


<pre><code><b>const</b> [ed25519.md#0x1_ed25519_E_WRONG_PUBKEY_SIZE](E_WRONG_PUBKEY_SIZE): u64 = 1;
</code></pre>



<a id="0x1_ed25519_E_WRONG_SIGNATURE_SIZE"></a>

Wrong number of bytes were given as input when deserializing an Ed25519 signature.


<pre><code><b>const</b> [ed25519.md#0x1_ed25519_E_WRONG_SIGNATURE_SIZE](E_WRONG_SIGNATURE_SIZE): u64 = 2;
</code></pre>



<a id="0x1_ed25519_SIGNATURE_NUM_BYTES"></a>

The size of a serialized signature, in bytes.


<pre><code><b>const</b> [ed25519.md#0x1_ed25519_SIGNATURE_NUM_BYTES](SIGNATURE_NUM_BYTES): u64 = 64;
</code></pre>



<a id="0x1_ed25519_SIGNATURE_SCHEME_ID"></a>

The identifier of the Ed25519 signature scheme, which is used when deriving Aptos authentication keys by hashing
it together with an Ed25519 public key.


<pre><code><b>const</b> [ed25519.md#0x1_ed25519_SIGNATURE_SCHEME_ID](SIGNATURE_SCHEME_ID): u8 = 0;
</code></pre>



<a id="0x1_ed25519_new_unvalidated_public_key_from_bytes"></a>

## Function `new_unvalidated_public_key_from_bytes`

Parses the input 32 bytes as an *unvalidated* Ed25519 public key.


<pre><code><b>public</b> <b>fun</b> [ed25519.md#0x1_ed25519_new_unvalidated_public_key_from_bytes](new_unvalidated_public_key_from_bytes)(bytes: [../../move-stdlib/doc/vector.md#0x1_vector](vector)&lt;u8&gt;): [ed25519.md#0x1_ed25519_UnvalidatedPublicKey](ed25519::UnvalidatedPublicKey)
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code><b>public</b> <b>fun</b> [ed25519.md#0x1_ed25519_new_unvalidated_public_key_from_bytes](new_unvalidated_public_key_from_bytes)(bytes: [../../move-stdlib/doc/vector.md#0x1_vector](vector)&lt;u8&gt;): [ed25519.md#0x1_ed25519_UnvalidatedPublicKey](UnvalidatedPublicKey) {
    <b>assert</b>!(std::vector::length(&bytes) == [ed25519.md#0x1_ed25519_PUBLIC_KEY_NUM_BYTES](PUBLIC_KEY_NUM_BYTES), std::error::invalid_argument([ed25519.md#0x1_ed25519_E_WRONG_PUBKEY_SIZE](E_WRONG_PUBKEY_SIZE)));
    [ed25519.md#0x1_ed25519_UnvalidatedPublicKey](UnvalidatedPublicKey) { bytes }
}
</code></pre>



</details>

<a id="0x1_ed25519_new_validated_public_key_from_bytes"></a>

## Function `new_validated_public_key_from_bytes`

Parses the input 32 bytes as a *validated* Ed25519 public key.


<pre><code><b>public</b> <b>fun</b> [ed25519.md#0x1_ed25519_new_validated_public_key_from_bytes](new_validated_public_key_from_bytes)(bytes: [../../move-stdlib/doc/vector.md#0x1_vector](vector)&lt;u8&gt;): [../../move-stdlib/doc/option.md#0x1_option_Option](option::Option)&lt;[ed25519.md#0x1_ed25519_ValidatedPublicKey](ed25519::ValidatedPublicKey)&gt;
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code><b>public</b> <b>fun</b> [ed25519.md#0x1_ed25519_new_validated_public_key_from_bytes](new_validated_public_key_from_bytes)(bytes: [../../move-stdlib/doc/vector.md#0x1_vector](vector)&lt;u8&gt;): Option&lt;[ed25519.md#0x1_ed25519_ValidatedPublicKey](ValidatedPublicKey)&gt; {
    <b>if</b> ([ed25519.md#0x1_ed25519_public_key_validate_internal](public_key_validate_internal)(bytes)) {
        [../../move-stdlib/doc/option.md#0x1_option_some](option::some)([ed25519.md#0x1_ed25519_ValidatedPublicKey](ValidatedPublicKey) {
            bytes
        })
    } <b>else</b> {
        [../../move-stdlib/doc/option.md#0x1_option_none](option::none)&lt;[ed25519.md#0x1_ed25519_ValidatedPublicKey](ValidatedPublicKey)&gt;()
    }
}
</code></pre>



</details>

<a id="0x1_ed25519_new_signature_from_bytes"></a>

## Function `new_signature_from_bytes`

Parses the input 64 bytes as a purported Ed25519 signature.


<pre><code><b>public</b> <b>fun</b> [ed25519.md#0x1_ed25519_new_signature_from_bytes](new_signature_from_bytes)(bytes: [../../move-stdlib/doc/vector.md#0x1_vector](vector)&lt;u8&gt;): [ed25519.md#0x1_ed25519_Signature](ed25519::Signature)
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code><b>public</b> <b>fun</b> [ed25519.md#0x1_ed25519_new_signature_from_bytes](new_signature_from_bytes)(bytes: [../../move-stdlib/doc/vector.md#0x1_vector](vector)&lt;u8&gt;): [ed25519.md#0x1_ed25519_Signature](Signature) {
    <b>assert</b>!(std::vector::length(&bytes) == [ed25519.md#0x1_ed25519_SIGNATURE_NUM_BYTES](SIGNATURE_NUM_BYTES), std::error::invalid_argument([ed25519.md#0x1_ed25519_E_WRONG_SIGNATURE_SIZE](E_WRONG_SIGNATURE_SIZE)));
    [ed25519.md#0x1_ed25519_Signature](Signature) { bytes }
}
</code></pre>



</details>

<a id="0x1_ed25519_public_key_to_unvalidated"></a>

## Function `public_key_to_unvalidated`

Converts a ValidatedPublicKey to an UnvalidatedPublicKey, which can be used in the strict verification APIs.


<pre><code><b>public</b> <b>fun</b> [ed25519.md#0x1_ed25519_public_key_to_unvalidated](public_key_to_unvalidated)(pk: &[ed25519.md#0x1_ed25519_ValidatedPublicKey](ed25519::ValidatedPublicKey)): [ed25519.md#0x1_ed25519_UnvalidatedPublicKey](ed25519::UnvalidatedPublicKey)
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code><b>public</b> <b>fun</b> [ed25519.md#0x1_ed25519_public_key_to_unvalidated](public_key_to_unvalidated)(pk: &[ed25519.md#0x1_ed25519_ValidatedPublicKey](ValidatedPublicKey)): [ed25519.md#0x1_ed25519_UnvalidatedPublicKey](UnvalidatedPublicKey) {
    [ed25519.md#0x1_ed25519_UnvalidatedPublicKey](UnvalidatedPublicKey) {
        bytes: pk.bytes
    }
}
</code></pre>



</details>

<a id="0x1_ed25519_public_key_into_unvalidated"></a>

## Function `public_key_into_unvalidated`

Moves a ValidatedPublicKey into an UnvalidatedPublicKey, which can be used in the strict verification APIs.


<pre><code><b>public</b> <b>fun</b> [ed25519.md#0x1_ed25519_public_key_into_unvalidated](public_key_into_unvalidated)(pk: [ed25519.md#0x1_ed25519_ValidatedPublicKey](ed25519::ValidatedPublicKey)): [ed25519.md#0x1_ed25519_UnvalidatedPublicKey](ed25519::UnvalidatedPublicKey)
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code><b>public</b> <b>fun</b> [ed25519.md#0x1_ed25519_public_key_into_unvalidated](public_key_into_unvalidated)(pk: [ed25519.md#0x1_ed25519_ValidatedPublicKey](ValidatedPublicKey)): [ed25519.md#0x1_ed25519_UnvalidatedPublicKey](UnvalidatedPublicKey) {
    [ed25519.md#0x1_ed25519_UnvalidatedPublicKey](UnvalidatedPublicKey) {
        bytes: pk.bytes
    }
}
</code></pre>



</details>

<a id="0x1_ed25519_unvalidated_public_key_to_bytes"></a>

## Function `unvalidated_public_key_to_bytes`

Serializes an UnvalidatedPublicKey struct to 32-bytes.


<pre><code><b>public</b> <b>fun</b> [ed25519.md#0x1_ed25519_unvalidated_public_key_to_bytes](unvalidated_public_key_to_bytes)(pk: &[ed25519.md#0x1_ed25519_UnvalidatedPublicKey](ed25519::UnvalidatedPublicKey)): [../../move-stdlib/doc/vector.md#0x1_vector](vector)&lt;u8&gt;
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code><b>public</b> <b>fun</b> [ed25519.md#0x1_ed25519_unvalidated_public_key_to_bytes](unvalidated_public_key_to_bytes)(pk: &[ed25519.md#0x1_ed25519_UnvalidatedPublicKey](UnvalidatedPublicKey)): [../../move-stdlib/doc/vector.md#0x1_vector](vector)&lt;u8&gt; {
    pk.bytes
}
</code></pre>



</details>

<a id="0x1_ed25519_validated_public_key_to_bytes"></a>

## Function `validated_public_key_to_bytes`

Serializes an ValidatedPublicKey struct to 32-bytes.


<pre><code><b>public</b> <b>fun</b> [ed25519.md#0x1_ed25519_validated_public_key_to_bytes](validated_public_key_to_bytes)(pk: &[ed25519.md#0x1_ed25519_ValidatedPublicKey](ed25519::ValidatedPublicKey)): [../../move-stdlib/doc/vector.md#0x1_vector](vector)&lt;u8&gt;
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code><b>public</b> <b>fun</b> [ed25519.md#0x1_ed25519_validated_public_key_to_bytes](validated_public_key_to_bytes)(pk: &[ed25519.md#0x1_ed25519_ValidatedPublicKey](ValidatedPublicKey)): [../../move-stdlib/doc/vector.md#0x1_vector](vector)&lt;u8&gt; {
    pk.bytes
}
</code></pre>



</details>

<a id="0x1_ed25519_signature_to_bytes"></a>

## Function `signature_to_bytes`

Serializes a Signature struct to 64-bytes.


<pre><code><b>public</b> <b>fun</b> [ed25519.md#0x1_ed25519_signature_to_bytes](signature_to_bytes)(sig: &[ed25519.md#0x1_ed25519_Signature](ed25519::Signature)): [../../move-stdlib/doc/vector.md#0x1_vector](vector)&lt;u8&gt;
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code><b>public</b> <b>fun</b> [ed25519.md#0x1_ed25519_signature_to_bytes](signature_to_bytes)(sig: &[ed25519.md#0x1_ed25519_Signature](Signature)): [../../move-stdlib/doc/vector.md#0x1_vector](vector)&lt;u8&gt; {
    sig.bytes
}
</code></pre>



</details>

<a id="0x1_ed25519_public_key_validate"></a>

## Function `public_key_validate`

Takes in an *unvalidated* public key and attempts to validate it.
Returns <code>Some([ed25519.md#0x1_ed25519_ValidatedPublicKey](ValidatedPublicKey))</code> if successful and <code>None</code> otherwise.


<pre><code><b>public</b> <b>fun</b> [ed25519.md#0x1_ed25519_public_key_validate](public_key_validate)(pk: &[ed25519.md#0x1_ed25519_UnvalidatedPublicKey](ed25519::UnvalidatedPublicKey)): [../../move-stdlib/doc/option.md#0x1_option_Option](option::Option)&lt;[ed25519.md#0x1_ed25519_ValidatedPublicKey](ed25519::ValidatedPublicKey)&gt;
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code><b>public</b> <b>fun</b> [ed25519.md#0x1_ed25519_public_key_validate](public_key_validate)(pk: &[ed25519.md#0x1_ed25519_UnvalidatedPublicKey](UnvalidatedPublicKey)): Option&lt;[ed25519.md#0x1_ed25519_ValidatedPublicKey](ValidatedPublicKey)&gt; {
    [ed25519.md#0x1_ed25519_new_validated_public_key_from_bytes](new_validated_public_key_from_bytes)(pk.bytes)
}
</code></pre>



</details>

<a id="0x1_ed25519_signature_verify_strict"></a>

## Function `signature_verify_strict`

Verifies a purported Ed25519 <code>signature</code> under an *unvalidated* <code>public_key</code> on the specified <code>message</code>.
This call will validate the public key by checking it is NOT in the small subgroup.


<pre><code><b>public</b> <b>fun</b> [ed25519.md#0x1_ed25519_signature_verify_strict](signature_verify_strict)(signature: &[ed25519.md#0x1_ed25519_Signature](ed25519::Signature), public_key: &[ed25519.md#0x1_ed25519_UnvalidatedPublicKey](ed25519::UnvalidatedPublicKey), message: [../../move-stdlib/doc/vector.md#0x1_vector](vector)&lt;u8&gt;): bool
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code><b>public</b> <b>fun</b> [ed25519.md#0x1_ed25519_signature_verify_strict](signature_verify_strict)(
    signature: &[ed25519.md#0x1_ed25519_Signature](Signature),
    public_key: &[ed25519.md#0x1_ed25519_UnvalidatedPublicKey](UnvalidatedPublicKey),
    message: [../../move-stdlib/doc/vector.md#0x1_vector](vector)&lt;u8&gt;
): bool {
    [ed25519.md#0x1_ed25519_signature_verify_strict_internal](signature_verify_strict_internal)(signature.bytes, public_key.bytes, message)
}
</code></pre>



</details>

<a id="0x1_ed25519_signature_verify_strict_t"></a>

## Function `signature_verify_strict_t`

This function is used to verify a signature on any BCS-serializable type T. For now, it is used to verify the
proof of private key ownership when rotating authentication keys.


<pre><code><b>public</b> <b>fun</b> [ed25519.md#0x1_ed25519_signature_verify_strict_t](signature_verify_strict_t)&lt;T: drop&gt;(signature: &[ed25519.md#0x1_ed25519_Signature](ed25519::Signature), public_key: &[ed25519.md#0x1_ed25519_UnvalidatedPublicKey](ed25519::UnvalidatedPublicKey), data: T): bool
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code><b>public</b> <b>fun</b> [ed25519.md#0x1_ed25519_signature_verify_strict_t](signature_verify_strict_t)&lt;T: drop&gt;(signature: &[ed25519.md#0x1_ed25519_Signature](Signature), public_key: &[ed25519.md#0x1_ed25519_UnvalidatedPublicKey](UnvalidatedPublicKey), data: T): bool {
    <b>let</b> encoded = [ed25519.md#0x1_ed25519_SignedMessage](SignedMessage) {
        [type_info.md#0x1_type_info](type_info): [type_info.md#0x1_type_info_type_of](type_info::type_of)&lt;T&gt;(),
        inner: data,
    };

    [ed25519.md#0x1_ed25519_signature_verify_strict_internal](signature_verify_strict_internal)(signature.bytes, public_key.bytes, [../../move-stdlib/doc/bcs.md#0x1_bcs_to_bytes](bcs::to_bytes)(&encoded))
}
</code></pre>



</details>

<a id="0x1_ed25519_new_signed_message"></a>

## Function `new_signed_message`

Helper method to construct a SignedMessage struct.


<pre><code><b>public</b> <b>fun</b> [ed25519.md#0x1_ed25519_new_signed_message](new_signed_message)&lt;T: drop&gt;(data: T): [ed25519.md#0x1_ed25519_SignedMessage](ed25519::SignedMessage)&lt;T&gt;
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code><b>public</b> <b>fun</b> [ed25519.md#0x1_ed25519_new_signed_message](new_signed_message)&lt;T: drop&gt;(data: T): [ed25519.md#0x1_ed25519_SignedMessage](SignedMessage)&lt;T&gt; {
    [ed25519.md#0x1_ed25519_SignedMessage](SignedMessage) {
        [type_info.md#0x1_type_info](type_info): [type_info.md#0x1_type_info_type_of](type_info::type_of)&lt;T&gt;(),
        inner: data,
    }
}
</code></pre>



</details>

<a id="0x1_ed25519_unvalidated_public_key_to_authentication_key"></a>

## Function `unvalidated_public_key_to_authentication_key`

Derives the Aptos-specific authentication key of the given Ed25519 public key.


<pre><code><b>public</b> <b>fun</b> [ed25519.md#0x1_ed25519_unvalidated_public_key_to_authentication_key](unvalidated_public_key_to_authentication_key)(pk: &[ed25519.md#0x1_ed25519_UnvalidatedPublicKey](ed25519::UnvalidatedPublicKey)): [../../move-stdlib/doc/vector.md#0x1_vector](vector)&lt;u8&gt;
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code><b>public</b> <b>fun</b> [ed25519.md#0x1_ed25519_unvalidated_public_key_to_authentication_key](unvalidated_public_key_to_authentication_key)(pk: &[ed25519.md#0x1_ed25519_UnvalidatedPublicKey](UnvalidatedPublicKey)): [../../move-stdlib/doc/vector.md#0x1_vector](vector)&lt;u8&gt; {
    [ed25519.md#0x1_ed25519_public_key_bytes_to_authentication_key](public_key_bytes_to_authentication_key)(pk.bytes)
}
</code></pre>



</details>

<a id="0x1_ed25519_validated_public_key_to_authentication_key"></a>

## Function `validated_public_key_to_authentication_key`

Derives the Aptos-specific authentication key of the given Ed25519 public key.


<pre><code><b>public</b> <b>fun</b> [ed25519.md#0x1_ed25519_validated_public_key_to_authentication_key](validated_public_key_to_authentication_key)(pk: &[ed25519.md#0x1_ed25519_ValidatedPublicKey](ed25519::ValidatedPublicKey)): [../../move-stdlib/doc/vector.md#0x1_vector](vector)&lt;u8&gt;
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code><b>public</b> <b>fun</b> [ed25519.md#0x1_ed25519_validated_public_key_to_authentication_key](validated_public_key_to_authentication_key)(pk: &[ed25519.md#0x1_ed25519_ValidatedPublicKey](ValidatedPublicKey)): [../../move-stdlib/doc/vector.md#0x1_vector](vector)&lt;u8&gt; {
    [ed25519.md#0x1_ed25519_public_key_bytes_to_authentication_key](public_key_bytes_to_authentication_key)(pk.bytes)
}
</code></pre>



</details>

<a id="0x1_ed25519_public_key_bytes_to_authentication_key"></a>

## Function `public_key_bytes_to_authentication_key`

Derives the Aptos-specific authentication key of the given Ed25519 public key.


<pre><code><b>fun</b> [ed25519.md#0x1_ed25519_public_key_bytes_to_authentication_key](public_key_bytes_to_authentication_key)(pk_bytes: [../../move-stdlib/doc/vector.md#0x1_vector](vector)&lt;u8&gt;): [../../move-stdlib/doc/vector.md#0x1_vector](vector)&lt;u8&gt;
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code><b>fun</b> [ed25519.md#0x1_ed25519_public_key_bytes_to_authentication_key](public_key_bytes_to_authentication_key)(pk_bytes: [../../move-stdlib/doc/vector.md#0x1_vector](vector)&lt;u8&gt;): [../../move-stdlib/doc/vector.md#0x1_vector](vector)&lt;u8&gt; {
    std::vector::push_back(&<b>mut</b> pk_bytes, [ed25519.md#0x1_ed25519_SIGNATURE_SCHEME_ID](SIGNATURE_SCHEME_ID));
    std::hash::sha3_256(pk_bytes)
}
</code></pre>



</details>

<a id="0x1_ed25519_public_key_validate_internal"></a>

## Function `public_key_validate_internal`

Return <code><b>true</b></code> if the bytes in <code>public_key</code> can be parsed as a valid Ed25519 public key: i.e., it passes
points-on-curve and not-in-small-subgroup checks.
Returns <code><b>false</b></code> otherwise.


<pre><code><b>fun</b> [ed25519.md#0x1_ed25519_public_key_validate_internal](public_key_validate_internal)(bytes: [../../move-stdlib/doc/vector.md#0x1_vector](vector)&lt;u8&gt;): bool
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code><b>native</b> <b>fun</b> [ed25519.md#0x1_ed25519_public_key_validate_internal](public_key_validate_internal)(bytes: [../../move-stdlib/doc/vector.md#0x1_vector](vector)&lt;u8&gt;): bool;
</code></pre>



</details>

<a id="0x1_ed25519_signature_verify_strict_internal"></a>

## Function `signature_verify_strict_internal`

Return true if the Ed25519 <code>signature</code> on <code>message</code> verifies against the Ed25519 <code>public_key</code>.
Returns <code><b>false</b></code> if either:
- <code>signature</code> or <code><b>public</b> key</code> are of wrong sizes
- <code>public_key</code> does not pass points-on-curve or not-in-small-subgroup checks,
- <code>signature</code> does not pass points-on-curve or not-in-small-subgroup checks,
- the signature on <code>message</code> does not verify.


<pre><code><b>fun</b> [ed25519.md#0x1_ed25519_signature_verify_strict_internal](signature_verify_strict_internal)(signature: [../../move-stdlib/doc/vector.md#0x1_vector](vector)&lt;u8&gt;, public_key: [../../move-stdlib/doc/vector.md#0x1_vector](vector)&lt;u8&gt;, message: [../../move-stdlib/doc/vector.md#0x1_vector](vector)&lt;u8&gt;): bool
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code><b>native</b> <b>fun</b> [ed25519.md#0x1_ed25519_signature_verify_strict_internal](signature_verify_strict_internal)(
    signature: [../../move-stdlib/doc/vector.md#0x1_vector](vector)&lt;u8&gt;,
    public_key: [../../move-stdlib/doc/vector.md#0x1_vector](vector)&lt;u8&gt;,
    message: [../../move-stdlib/doc/vector.md#0x1_vector](vector)&lt;u8&gt;
): bool;
</code></pre>



</details>

<a id="@Specification_1"></a>

## Specification


<a id="@Specification_1_new_unvalidated_public_key_from_bytes"></a>

### Function `new_unvalidated_public_key_from_bytes`


<pre><code><b>public</b> <b>fun</b> [ed25519.md#0x1_ed25519_new_unvalidated_public_key_from_bytes](new_unvalidated_public_key_from_bytes)(bytes: [../../move-stdlib/doc/vector.md#0x1_vector](vector)&lt;u8&gt;): [ed25519.md#0x1_ed25519_UnvalidatedPublicKey](ed25519::UnvalidatedPublicKey)
</code></pre>




<pre><code><b>include</b> [ed25519.md#0x1_ed25519_NewUnvalidatedPublicKeyFromBytesAbortsIf](NewUnvalidatedPublicKeyFromBytesAbortsIf);
<b>ensures</b> result == [ed25519.md#0x1_ed25519_UnvalidatedPublicKey](UnvalidatedPublicKey) { bytes };
</code></pre>




<a id="0x1_ed25519_NewUnvalidatedPublicKeyFromBytesAbortsIf"></a>


<pre><code><b>schema</b> [ed25519.md#0x1_ed25519_NewUnvalidatedPublicKeyFromBytesAbortsIf](NewUnvalidatedPublicKeyFromBytesAbortsIf) {
    bytes: [../../move-stdlib/doc/vector.md#0x1_vector](vector)&lt;u8&gt;;
    <b>aborts_if</b> len(bytes) != [ed25519.md#0x1_ed25519_PUBLIC_KEY_NUM_BYTES](PUBLIC_KEY_NUM_BYTES);
}
</code></pre>



<a id="@Specification_1_new_validated_public_key_from_bytes"></a>

### Function `new_validated_public_key_from_bytes`


<pre><code><b>public</b> <b>fun</b> [ed25519.md#0x1_ed25519_new_validated_public_key_from_bytes](new_validated_public_key_from_bytes)(bytes: [../../move-stdlib/doc/vector.md#0x1_vector](vector)&lt;u8&gt;): [../../move-stdlib/doc/option.md#0x1_option_Option](option::Option)&lt;[ed25519.md#0x1_ed25519_ValidatedPublicKey](ed25519::ValidatedPublicKey)&gt;
</code></pre>




<pre><code><b>aborts_if</b> <b>false</b>;
<b>let</b> cond = [ed25519.md#0x1_ed25519_spec_public_key_validate_internal](spec_public_key_validate_internal)(bytes);
<b>ensures</b> cond ==&gt; result == [../../move-stdlib/doc/option.md#0x1_option_spec_some](option::spec_some)([ed25519.md#0x1_ed25519_ValidatedPublicKey](ValidatedPublicKey){bytes});
<b>ensures</b> !cond ==&gt; result == [../../move-stdlib/doc/option.md#0x1_option_spec_none](option::spec_none)&lt;[ed25519.md#0x1_ed25519_ValidatedPublicKey](ValidatedPublicKey)&gt;();
</code></pre>



<a id="@Specification_1_new_signature_from_bytes"></a>

### Function `new_signature_from_bytes`


<pre><code><b>public</b> <b>fun</b> [ed25519.md#0x1_ed25519_new_signature_from_bytes](new_signature_from_bytes)(bytes: [../../move-stdlib/doc/vector.md#0x1_vector](vector)&lt;u8&gt;): [ed25519.md#0x1_ed25519_Signature](ed25519::Signature)
</code></pre>




<pre><code><b>include</b> [ed25519.md#0x1_ed25519_NewSignatureFromBytesAbortsIf](NewSignatureFromBytesAbortsIf);
<b>ensures</b> result == [ed25519.md#0x1_ed25519_Signature](Signature) { bytes };
</code></pre>




<a id="0x1_ed25519_NewSignatureFromBytesAbortsIf"></a>


<pre><code><b>schema</b> [ed25519.md#0x1_ed25519_NewSignatureFromBytesAbortsIf](NewSignatureFromBytesAbortsIf) {
    bytes: [../../move-stdlib/doc/vector.md#0x1_vector](vector)&lt;u8&gt;;
    <b>aborts_if</b> len(bytes) != [ed25519.md#0x1_ed25519_SIGNATURE_NUM_BYTES](SIGNATURE_NUM_BYTES);
}
</code></pre>



<a id="@Specification_1_public_key_bytes_to_authentication_key"></a>

### Function `public_key_bytes_to_authentication_key`


<pre><code><b>fun</b> [ed25519.md#0x1_ed25519_public_key_bytes_to_authentication_key](public_key_bytes_to_authentication_key)(pk_bytes: [../../move-stdlib/doc/vector.md#0x1_vector](vector)&lt;u8&gt;): [../../move-stdlib/doc/vector.md#0x1_vector](vector)&lt;u8&gt;
</code></pre>




<pre><code><b>pragma</b> opaque;
<b>aborts_if</b> <b>false</b>;
<b>ensures</b> [abstract] result == [ed25519.md#0x1_ed25519_spec_public_key_bytes_to_authentication_key](spec_public_key_bytes_to_authentication_key)(pk_bytes);
</code></pre>



<a id="@Specification_1_public_key_validate_internal"></a>

### Function `public_key_validate_internal`


<pre><code><b>fun</b> [ed25519.md#0x1_ed25519_public_key_validate_internal](public_key_validate_internal)(bytes: [../../move-stdlib/doc/vector.md#0x1_vector](vector)&lt;u8&gt;): bool
</code></pre>




<pre><code><b>pragma</b> opaque;
<b>aborts_if</b> <b>false</b>;
<b>ensures</b> result == [ed25519.md#0x1_ed25519_spec_public_key_validate_internal](spec_public_key_validate_internal)(bytes);
</code></pre>



<a id="@Specification_1_signature_verify_strict_internal"></a>

### Function `signature_verify_strict_internal`


<pre><code><b>fun</b> [ed25519.md#0x1_ed25519_signature_verify_strict_internal](signature_verify_strict_internal)(signature: [../../move-stdlib/doc/vector.md#0x1_vector](vector)&lt;u8&gt;, public_key: [../../move-stdlib/doc/vector.md#0x1_vector](vector)&lt;u8&gt;, message: [../../move-stdlib/doc/vector.md#0x1_vector](vector)&lt;u8&gt;): bool
</code></pre>




<pre><code><b>pragma</b> opaque;
<b>aborts_if</b> <b>false</b>;
<b>ensures</b> result == [ed25519.md#0x1_ed25519_spec_signature_verify_strict_internal](spec_signature_verify_strict_internal)(signature, public_key, message);
</code></pre>



<a id="@Helper_functions_2"></a>

### Helper functions



<a id="0x1_ed25519_spec_signature_verify_strict_internal"></a>


<pre><code><b>fun</b> [ed25519.md#0x1_ed25519_spec_signature_verify_strict_internal](spec_signature_verify_strict_internal)(
   signature: [../../move-stdlib/doc/vector.md#0x1_vector](vector)&lt;u8&gt;,
   public_key: [../../move-stdlib/doc/vector.md#0x1_vector](vector)&lt;u8&gt;,
   message: [../../move-stdlib/doc/vector.md#0x1_vector](vector)&lt;u8&gt;
): bool;
</code></pre>




<a id="0x1_ed25519_spec_public_key_validate_internal"></a>


<pre><code><b>fun</b> [ed25519.md#0x1_ed25519_spec_public_key_validate_internal](spec_public_key_validate_internal)(bytes: [../../move-stdlib/doc/vector.md#0x1_vector](vector)&lt;u8&gt;): bool;
</code></pre>




<a id="0x1_ed25519_spec_public_key_bytes_to_authentication_key"></a>


<pre><code><b>fun</b> [ed25519.md#0x1_ed25519_spec_public_key_bytes_to_authentication_key](spec_public_key_bytes_to_authentication_key)(pk_bytes: [../../move-stdlib/doc/vector.md#0x1_vector](vector)&lt;u8&gt;): [../../move-stdlib/doc/vector.md#0x1_vector](vector)&lt;u8&gt;;
</code></pre>




<a id="0x1_ed25519_spec_signature_verify_strict_t"></a>


<pre><code><b>fun</b> [ed25519.md#0x1_ed25519_spec_signature_verify_strict_t](spec_signature_verify_strict_t)&lt;T&gt;(signature: [ed25519.md#0x1_ed25519_Signature](Signature), public_key: [ed25519.md#0x1_ed25519_UnvalidatedPublicKey](UnvalidatedPublicKey), data: T): bool {
   <b>let</b> encoded = [ed25519.md#0x1_ed25519_SignedMessage](SignedMessage)&lt;T&gt; {
       [type_info.md#0x1_type_info](type_info): [type_info.md#0x1_type_info_type_of](type_info::type_of)&lt;T&gt;(),
       inner: data,
   };
   <b>let</b> message = [../../move-stdlib/doc/bcs.md#0x1_bcs_serialize](bcs::serialize)(encoded);
   [ed25519.md#0x1_ed25519_spec_signature_verify_strict_internal](spec_signature_verify_strict_internal)(signature.bytes, public_key.bytes, message)
}
</code></pre>


[move-book]: https://aptos.dev/move/book/SUMMARY
