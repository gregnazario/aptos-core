
<a id="0x1_ed25519"></a>

# Module `0x1::ed25519`

Contains functions for:

1. [Ed25519](https://en.wikipedia.org/wiki/EdDSA#Ed25519) digital signatures: i.e., EdDSA signatures over Edwards25519 curves with co&#45;factor 8


-  [Struct `SignedMessage`](#0x1_ed25519_SignedMessage)
-  [Struct `UnvalidatedPublicKey`](#0x1_ed25519_UnvalidatedPublicKey)
-  [Struct `ValidatedPublicKey`](#0x1_ed25519_ValidatedPublicKey)
-  [Struct `Signature`](#0x1_ed25519_Signature)
-  [Constants](#@Constants_0)
-  [Function `new_unvalidated_public_key_from_bytes`](#0x1_ed25519_new_unvalidated_public_key_from_bytes)
-  [Function `new_validated_public_key_from_bytes`](#0x1_ed25519_new_validated_public_key_from_bytes)
-  [Function `new_signature_from_bytes`](#0x1_ed25519_new_signature_from_bytes)
-  [Function `public_key_to_unvalidated`](#0x1_ed25519_public_key_to_unvalidated)
-  [Function `public_key_into_unvalidated`](#0x1_ed25519_public_key_into_unvalidated)
-  [Function `unvalidated_public_key_to_bytes`](#0x1_ed25519_unvalidated_public_key_to_bytes)
-  [Function `validated_public_key_to_bytes`](#0x1_ed25519_validated_public_key_to_bytes)
-  [Function `signature_to_bytes`](#0x1_ed25519_signature_to_bytes)
-  [Function `public_key_validate`](#0x1_ed25519_public_key_validate)
-  [Function `signature_verify_strict`](#0x1_ed25519_signature_verify_strict)
-  [Function `signature_verify_strict_t`](#0x1_ed25519_signature_verify_strict_t)
-  [Function `new_signed_message`](#0x1_ed25519_new_signed_message)
-  [Function `unvalidated_public_key_to_authentication_key`](#0x1_ed25519_unvalidated_public_key_to_authentication_key)
-  [Function `validated_public_key_to_authentication_key`](#0x1_ed25519_validated_public_key_to_authentication_key)
-  [Function `public_key_bytes_to_authentication_key`](#0x1_ed25519_public_key_bytes_to_authentication_key)
-  [Function `public_key_validate_internal`](#0x1_ed25519_public_key_validate_internal)
-  [Function `signature_verify_strict_internal`](#0x1_ed25519_signature_verify_strict_internal)
-  [Specification](#@Specification_1)
    -  [Function `new_unvalidated_public_key_from_bytes`](#@Specification_1_new_unvalidated_public_key_from_bytes)
    -  [Function `new_validated_public_key_from_bytes`](#@Specification_1_new_validated_public_key_from_bytes)
    -  [Function `new_signature_from_bytes`](#@Specification_1_new_signature_from_bytes)
    -  [Function `public_key_bytes_to_authentication_key`](#@Specification_1_public_key_bytes_to_authentication_key)
    -  [Function `public_key_validate_internal`](#@Specification_1_public_key_validate_internal)
    -  [Function `signature_verify_strict_internal`](#@Specification_1_signature_verify_strict_internal)
    -  [Helper functions](#@Helper_functions_2)


```move
module 0x1::ed25519 {
    use 0x1::bcs;
    use 0x1::error;
    use 0x1::hash;
    use 0x1::option;
    use 0x1::type_info;
}
```


<a id="0x1_ed25519_SignedMessage"></a>

## Struct `SignedMessage`

A BCS&#45;serializable message, which one can verify signatures on via `signature_verify_strict_t`


```move
module 0x1::ed25519 {
    struct SignedMessage<MessageType> has drop
}
```


##### Fields


<dl>
<dt>
`type_info: type_info::TypeInfo`
</dt>
<dd>

</dd>
<dt>
`inner: MessageType`
</dt>
<dd>

</dd>
</dl>


<a id="0x1_ed25519_UnvalidatedPublicKey"></a>

## Struct `UnvalidatedPublicKey`

An &#42;unvalidated&#42; Ed25519 public key: not necessarily an elliptic curve point, just a sequence of 32 bytes


```move
module 0x1::ed25519 {
    struct UnvalidatedPublicKey has copy, drop, store
}
```


##### Fields


<dl>
<dt>
`bytes: vector<u8>`
</dt>
<dd>

</dd>
</dl>


<a id="0x1_ed25519_ValidatedPublicKey"></a>

## Struct `ValidatedPublicKey`

A &#42;validated&#42; Ed25519 public key: not necessarily a prime&#45;order point, could be mixed&#45;order, but will never be
a small&#45;order point.

For now, this struct is not used in any verification functions, but it might be in the future.


```move
module 0x1::ed25519 {
    struct ValidatedPublicKey has copy, drop, store
}
```


##### Fields


<dl>
<dt>
`bytes: vector<u8>`
</dt>
<dd>

</dd>
</dl>


<a id="0x1_ed25519_Signature"></a>

## Struct `Signature`

A purported Ed25519 signature that can be verified via `signature_verify_strict` or `signature_verify_strict_t`.


```move
module 0x1::ed25519 {
    struct Signature has copy, drop, store
}
```


##### Fields


<dl>
<dt>
`bytes: vector<u8>`
</dt>
<dd>

</dd>
</dl>


<a id="@Constants_0"></a>

## Constants


<a id="0x1_ed25519_PUBLIC_KEY_NUM_BYTES"></a>

The size of a serialized public key, in bytes.


```move
module 0x1::ed25519 {
    const PUBLIC_KEY_NUM_BYTES: u64 = 32;
}
```


<a id="0x1_ed25519_E_WRONG_PUBKEY_SIZE"></a>

Wrong number of bytes were given as input when deserializing an Ed25519 public key.


```move
module 0x1::ed25519 {
    const E_WRONG_PUBKEY_SIZE: u64 = 1;
}
```


<a id="0x1_ed25519_E_WRONG_SIGNATURE_SIZE"></a>

Wrong number of bytes were given as input when deserializing an Ed25519 signature.


```move
module 0x1::ed25519 {
    const E_WRONG_SIGNATURE_SIZE: u64 = 2;
}
```


<a id="0x1_ed25519_SIGNATURE_NUM_BYTES"></a>

The size of a serialized signature, in bytes.


```move
module 0x1::ed25519 {
    const SIGNATURE_NUM_BYTES: u64 = 64;
}
```


<a id="0x1_ed25519_SIGNATURE_SCHEME_ID"></a>

The identifier of the Ed25519 signature scheme, which is used when deriving Aptos authentication keys by hashing
it together with an Ed25519 public key.


```move
module 0x1::ed25519 {
    const SIGNATURE_SCHEME_ID: u8 = 0;
}
```


<a id="0x1_ed25519_new_unvalidated_public_key_from_bytes"></a>

## Function `new_unvalidated_public_key_from_bytes`

Parses the input 32 bytes as an &#42;unvalidated&#42; Ed25519 public key.


```move
module 0x1::ed25519 {
    public fun new_unvalidated_public_key_from_bytes(bytes: vector<u8>): ed25519::UnvalidatedPublicKey
}
```


##### Implementation


```move
module 0x1::ed25519 {
    public fun new_unvalidated_public_key_from_bytes(bytes: vector<u8>): UnvalidatedPublicKey {
        assert!(std::vector::length(&bytes) == PUBLIC_KEY_NUM_BYTES, std::error::invalid_argument(E_WRONG_PUBKEY_SIZE));
        UnvalidatedPublicKey { bytes }
    }
}
```


<a id="0x1_ed25519_new_validated_public_key_from_bytes"></a>

## Function `new_validated_public_key_from_bytes`

Parses the input 32 bytes as a &#42;validated&#42; Ed25519 public key.


```move
module 0x1::ed25519 {
    public fun new_validated_public_key_from_bytes(bytes: vector<u8>): option::Option<ed25519::ValidatedPublicKey>
}
```


##### Implementation


```move
module 0x1::ed25519 {
    public fun new_validated_public_key_from_bytes(bytes: vector<u8>): Option<ValidatedPublicKey> {
        if (public_key_validate_internal(bytes)) {
            option::some(ValidatedPublicKey {
                bytes
            })
        } else {
            option::none<ValidatedPublicKey>()
        }
    }
}
```


<a id="0x1_ed25519_new_signature_from_bytes"></a>

## Function `new_signature_from_bytes`

Parses the input 64 bytes as a purported Ed25519 signature.


```move
module 0x1::ed25519 {
    public fun new_signature_from_bytes(bytes: vector<u8>): ed25519::Signature
}
```


##### Implementation


```move
module 0x1::ed25519 {
    public fun new_signature_from_bytes(bytes: vector<u8>): Signature {
        assert!(std::vector::length(&bytes) == SIGNATURE_NUM_BYTES, std::error::invalid_argument(E_WRONG_SIGNATURE_SIZE));
        Signature { bytes }
    }
}
```


<a id="0x1_ed25519_public_key_to_unvalidated"></a>

## Function `public_key_to_unvalidated`

Converts a ValidatedPublicKey to an UnvalidatedPublicKey, which can be used in the strict verification APIs.


```move
module 0x1::ed25519 {
    public fun public_key_to_unvalidated(pk: &ed25519::ValidatedPublicKey): ed25519::UnvalidatedPublicKey
}
```


##### Implementation


```move
module 0x1::ed25519 {
    public fun public_key_to_unvalidated(pk: &ValidatedPublicKey): UnvalidatedPublicKey {
        UnvalidatedPublicKey {
            bytes: pk.bytes
        }
    }
}
```


<a id="0x1_ed25519_public_key_into_unvalidated"></a>

## Function `public_key_into_unvalidated`

Moves a ValidatedPublicKey into an UnvalidatedPublicKey, which can be used in the strict verification APIs.


```move
module 0x1::ed25519 {
    public fun public_key_into_unvalidated(pk: ed25519::ValidatedPublicKey): ed25519::UnvalidatedPublicKey
}
```


##### Implementation


```move
module 0x1::ed25519 {
    public fun public_key_into_unvalidated(pk: ValidatedPublicKey): UnvalidatedPublicKey {
        UnvalidatedPublicKey {
            bytes: pk.bytes
        }
    }
}
```


<a id="0x1_ed25519_unvalidated_public_key_to_bytes"></a>

## Function `unvalidated_public_key_to_bytes`

Serializes an UnvalidatedPublicKey struct to 32&#45;bytes.


```move
module 0x1::ed25519 {
    public fun unvalidated_public_key_to_bytes(pk: &ed25519::UnvalidatedPublicKey): vector<u8>
}
```


##### Implementation


```move
module 0x1::ed25519 {
    public fun unvalidated_public_key_to_bytes(pk: &UnvalidatedPublicKey): vector<u8> {
        pk.bytes
    }
}
```


<a id="0x1_ed25519_validated_public_key_to_bytes"></a>

## Function `validated_public_key_to_bytes`

Serializes an ValidatedPublicKey struct to 32&#45;bytes.


```move
module 0x1::ed25519 {
    public fun validated_public_key_to_bytes(pk: &ed25519::ValidatedPublicKey): vector<u8>
}
```


##### Implementation


```move
module 0x1::ed25519 {
    public fun validated_public_key_to_bytes(pk: &ValidatedPublicKey): vector<u8> {
        pk.bytes
    }
}
```


<a id="0x1_ed25519_signature_to_bytes"></a>

## Function `signature_to_bytes`

Serializes a Signature struct to 64&#45;bytes.


```move
module 0x1::ed25519 {
    public fun signature_to_bytes(sig: &ed25519::Signature): vector<u8>
}
```


##### Implementation


```move
module 0x1::ed25519 {
    public fun signature_to_bytes(sig: &Signature): vector<u8> {
        sig.bytes
    }
}
```


<a id="0x1_ed25519_public_key_validate"></a>

## Function `public_key_validate`

Takes in an &#42;unvalidated&#42; public key and attempts to validate it.
Returns `Some(ValidatedPublicKey)` if successful and `None` otherwise.


```move
module 0x1::ed25519 {
    public fun public_key_validate(pk: &ed25519::UnvalidatedPublicKey): option::Option<ed25519::ValidatedPublicKey>
}
```


##### Implementation


```move
module 0x1::ed25519 {
    public fun public_key_validate(pk: &UnvalidatedPublicKey): Option<ValidatedPublicKey> {
        new_validated_public_key_from_bytes(pk.bytes)
    }
}
```


<a id="0x1_ed25519_signature_verify_strict"></a>

## Function `signature_verify_strict`

Verifies a purported Ed25519 `signature` under an &#42;unvalidated&#42; `public_key` on the specified `message`.
This call will validate the public key by checking it is NOT in the small subgroup.


```move
module 0x1::ed25519 {
    public fun signature_verify_strict(signature: &ed25519::Signature, public_key: &ed25519::UnvalidatedPublicKey, message: vector<u8>): bool
}
```


##### Implementation


```move
module 0x1::ed25519 {
    public fun signature_verify_strict(
        signature: &Signature,
        public_key: &UnvalidatedPublicKey,
        message: vector<u8>
    ): bool {
        signature_verify_strict_internal(signature.bytes, public_key.bytes, message)
    }
}
```


<a id="0x1_ed25519_signature_verify_strict_t"></a>

## Function `signature_verify_strict_t`

This function is used to verify a signature on any BCS&#45;serializable type T. For now, it is used to verify the
proof of private key ownership when rotating authentication keys.


```move
module 0x1::ed25519 {
    public fun signature_verify_strict_t<T: drop>(signature: &ed25519::Signature, public_key: &ed25519::UnvalidatedPublicKey, data: T): bool
}
```


##### Implementation


```move
module 0x1::ed25519 {
    public fun signature_verify_strict_t<T: drop>(signature: &Signature, public_key: &UnvalidatedPublicKey, data: T): bool {
        let encoded = SignedMessage {
            type_info: type_info::type_of<T>(),
            inner: data,
        };

        signature_verify_strict_internal(signature.bytes, public_key.bytes, bcs::to_bytes(&encoded))
    }
}
```


<a id="0x1_ed25519_new_signed_message"></a>

## Function `new_signed_message`

Helper method to construct a SignedMessage struct.


```move
module 0x1::ed25519 {
    public fun new_signed_message<T: drop>(data: T): ed25519::SignedMessage<T>
}
```


##### Implementation


```move
module 0x1::ed25519 {
    public fun new_signed_message<T: drop>(data: T): SignedMessage<T> {
        SignedMessage {
            type_info: type_info::type_of<T>(),
            inner: data,
        }
    }
}
```


<a id="0x1_ed25519_unvalidated_public_key_to_authentication_key"></a>

## Function `unvalidated_public_key_to_authentication_key`

Derives the Aptos&#45;specific authentication key of the given Ed25519 public key.


```move
module 0x1::ed25519 {
    public fun unvalidated_public_key_to_authentication_key(pk: &ed25519::UnvalidatedPublicKey): vector<u8>
}
```


##### Implementation


```move
module 0x1::ed25519 {
    public fun unvalidated_public_key_to_authentication_key(pk: &UnvalidatedPublicKey): vector<u8> {
        public_key_bytes_to_authentication_key(pk.bytes)
    }
}
```


<a id="0x1_ed25519_validated_public_key_to_authentication_key"></a>

## Function `validated_public_key_to_authentication_key`

Derives the Aptos&#45;specific authentication key of the given Ed25519 public key.


```move
module 0x1::ed25519 {
    public fun validated_public_key_to_authentication_key(pk: &ed25519::ValidatedPublicKey): vector<u8>
}
```


##### Implementation


```move
module 0x1::ed25519 {
    public fun validated_public_key_to_authentication_key(pk: &ValidatedPublicKey): vector<u8> {
        public_key_bytes_to_authentication_key(pk.bytes)
    }
}
```


<a id="0x1_ed25519_public_key_bytes_to_authentication_key"></a>

## Function `public_key_bytes_to_authentication_key`

Derives the Aptos&#45;specific authentication key of the given Ed25519 public key.


```move
module 0x1::ed25519 {
    fun public_key_bytes_to_authentication_key(pk_bytes: vector<u8>): vector<u8>
}
```


##### Implementation


```move
module 0x1::ed25519 {
    fun public_key_bytes_to_authentication_key(pk_bytes: vector<u8>): vector<u8> {
        std::vector::push_back(&mut pk_bytes, SIGNATURE_SCHEME_ID);
        std::hash::sha3_256(pk_bytes)
    }
}
```


<a id="0x1_ed25519_public_key_validate_internal"></a>

## Function `public_key_validate_internal`

Return `true` if the bytes in `public_key` can be parsed as a valid Ed25519 public key: i.e., it passes
points&#45;on&#45;curve and not&#45;in&#45;small&#45;subgroup checks.
Returns `false` otherwise.


```move
module 0x1::ed25519 {
    fun public_key_validate_internal(bytes: vector<u8>): bool
}
```


##### Implementation


```move
module 0x1::ed25519 {
    native fun public_key_validate_internal(bytes: vector<u8>): bool;
}
```


<a id="0x1_ed25519_signature_verify_strict_internal"></a>

## Function `signature_verify_strict_internal`

Return true if the Ed25519 `signature` on `message` verifies against the Ed25519 `public_key`.
Returns `false` if either:
&#45; `signature` or `public key` are of wrong sizes
&#45; `public_key` does not pass points&#45;on&#45;curve or not&#45;in&#45;small&#45;subgroup checks,
&#45; `signature` does not pass points&#45;on&#45;curve or not&#45;in&#45;small&#45;subgroup checks,
&#45; the signature on `message` does not verify.


```move
module 0x1::ed25519 {
    fun signature_verify_strict_internal(signature: vector<u8>, public_key: vector<u8>, message: vector<u8>): bool
}
```


##### Implementation


```move
module 0x1::ed25519 {
    native fun signature_verify_strict_internal(
        signature: vector<u8>,
        public_key: vector<u8>,
        message: vector<u8>
    ): bool;
}
```


<a id="@Specification_1"></a>

## Specification


<a id="@Specification_1_new_unvalidated_public_key_from_bytes"></a>

### Function `new_unvalidated_public_key_from_bytes`


```move
module 0x1::ed25519 {
    public fun new_unvalidated_public_key_from_bytes(bytes: vector<u8>): ed25519::UnvalidatedPublicKey
}
```



```move
module 0x1::ed25519 {
    include NewUnvalidatedPublicKeyFromBytesAbortsIf;
    ensures result == UnvalidatedPublicKey { bytes };
}
```



<a id="0x1_ed25519_NewUnvalidatedPublicKeyFromBytesAbortsIf"></a>


```move
module 0x1::ed25519 {
    schema NewUnvalidatedPublicKeyFromBytesAbortsIf {
        bytes: vector<u8>;
        aborts_if len(bytes) != PUBLIC_KEY_NUM_BYTES;
    }
}
```


<a id="@Specification_1_new_validated_public_key_from_bytes"></a>

### Function `new_validated_public_key_from_bytes`


```move
module 0x1::ed25519 {
    public fun new_validated_public_key_from_bytes(bytes: vector<u8>): option::Option<ed25519::ValidatedPublicKey>
}
```



```move
module 0x1::ed25519 {
    aborts_if false;
    let cond = spec_public_key_validate_internal(bytes);
    ensures cond ==> result == option::spec_some(ValidatedPublicKey{bytes});
    ensures !cond ==> result == option::spec_none<ValidatedPublicKey>();
}
```


<a id="@Specification_1_new_signature_from_bytes"></a>

### Function `new_signature_from_bytes`


```move
module 0x1::ed25519 {
    public fun new_signature_from_bytes(bytes: vector<u8>): ed25519::Signature
}
```



```move
module 0x1::ed25519 {
    include NewSignatureFromBytesAbortsIf;
    ensures result == Signature { bytes };
}
```



<a id="0x1_ed25519_NewSignatureFromBytesAbortsIf"></a>


```move
module 0x1::ed25519 {
    schema NewSignatureFromBytesAbortsIf {
        bytes: vector<u8>;
        aborts_if len(bytes) != SIGNATURE_NUM_BYTES;
    }
}
```


<a id="@Specification_1_public_key_bytes_to_authentication_key"></a>

### Function `public_key_bytes_to_authentication_key`


```move
module 0x1::ed25519 {
    fun public_key_bytes_to_authentication_key(pk_bytes: vector<u8>): vector<u8>
}
```



```move
module 0x1::ed25519 {
    pragma opaque;
    aborts_if false;
    ensures [abstract] result == spec_public_key_bytes_to_authentication_key(pk_bytes);
}
```


<a id="@Specification_1_public_key_validate_internal"></a>

### Function `public_key_validate_internal`


```move
module 0x1::ed25519 {
    fun public_key_validate_internal(bytes: vector<u8>): bool
}
```



```move
module 0x1::ed25519 {
    pragma opaque;
    aborts_if false;
    ensures result == spec_public_key_validate_internal(bytes);
}
```


<a id="@Specification_1_signature_verify_strict_internal"></a>

### Function `signature_verify_strict_internal`


```move
module 0x1::ed25519 {
    fun signature_verify_strict_internal(signature: vector<u8>, public_key: vector<u8>, message: vector<u8>): bool
}
```



```move
module 0x1::ed25519 {
    pragma opaque;
    aborts_if false;
    ensures result == spec_signature_verify_strict_internal(signature, public_key, message);
}
```


<a id="@Helper_functions_2"></a>

### Helper functions



<a id="0x1_ed25519_spec_signature_verify_strict_internal"></a>


```move
module 0x1::ed25519 {
    fun spec_signature_verify_strict_internal(
       signature: vector<u8>,
       public_key: vector<u8>,
       message: vector<u8>
    ): bool;
}
```



<a id="0x1_ed25519_spec_public_key_validate_internal"></a>


```move
module 0x1::ed25519 {
    fun spec_public_key_validate_internal(bytes: vector<u8>): bool;
}
```



<a id="0x1_ed25519_spec_public_key_bytes_to_authentication_key"></a>


```move
module 0x1::ed25519 {
    fun spec_public_key_bytes_to_authentication_key(pk_bytes: vector<u8>): vector<u8>;
}
```



<a id="0x1_ed25519_spec_signature_verify_strict_t"></a>


```move
module 0x1::ed25519 {
    fun spec_signature_verify_strict_t<T>(signature: Signature, public_key: UnvalidatedPublicKey, data: T): bool {
       let encoded = SignedMessage<T> {
           type_info: type_info::type_of<T>(),
           inner: data,
       };
       let message = bcs::serialize(encoded);
       spec_signature_verify_strict_internal(signature.bytes, public_key.bytes, message)
    }
}
```
